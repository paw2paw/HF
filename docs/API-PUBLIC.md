# HF Platform API Guide

> The official API reference for integrating with HF — a behaviour-driven,
> memory-adaptive conversational AI platform.
>
> **Version**: 1.0
> **Last generated**: 2026-02-22

<!-- DO NOT EDIT DIRECTLY -->
<!-- This file is auto-generated by scripts/api-docs/generator.ts -->
<!-- To update: modify @api annotations in route.ts files, then run: -->
<!--   npx tsx scripts/api-docs/generator.ts -->

> **Do not edit this file directly.** Update the `@api` JSDoc annotations
> in the corresponding `route.ts` files, or edit the template files in
> `apps/admin/scripts/api-docs/templates/`, then regenerate:
> ```bash
> npx tsx scripts/api-docs/generator.ts
> ```

---

## Table of Contents

- [Introduction](#introduction)
- [Quick Start](#quick-start)
- [Authentication](#authentication)
- [Rate Limits](#rate-limits)
- [Common Patterns](#common-patterns)
- [API Reference](#api-reference)
  - [Account](#account)
  - [Callers](#callers)
  - [Calls](#calls)
  - [Cohorts](#cohorts)
  - [Communities](#communities)
  - [Content Trust](#content-trust)
  - [Curricula](#curricula)
  - [Domains](#domains)
  - [Goals](#goals)
  - [Invites](#invites)
  - [Layers](#layers)
  - [Memories](#memories)
  - [Other](#other)
  - [Parameters](#parameters)
  - [Pipeline](#pipeline)
  - [Playbooks](#playbooks)
  - [Prompts](#prompts)
  - [Specs](#specs)
  - [Subjects](#subjects)
  - [System](#system)
  - [Transcripts](#transcripts)
  - [Vapi](#vapi)
- [Voice Integration](#voice-integration)
- [Deployment](#deployment)
- [Versioning](#versioning)
- [Security](#security)

---

## Introduction

HF is a behaviour-driven, memory-adaptive conversational AI platform. It builds
rich personality profiles from live conversations, extracts and recalls memories,
and composes personalised prompts that make every interaction feel human.

### What you can do with the API

| Capability | Description |
|-----------|-------------|
| **Caller Management** | Create and query caller profiles, memories, and personality data |
| **Call Processing** | Submit transcripts, trigger the analysis pipeline, retrieve insights |
| **Prompt Composition** | Generate context-aware system prompts for any LLM |
| **Behaviour Specs** | Define, activate, and query BDD analysis specifications |
| **Playbooks** | Configure domain-specific conversation playbooks |
| **Webhooks** | Receive real-time event notifications for pipeline completions |

### Deployment models

HF supports two deployment models:

- **Cloud** -- Managed multi-tenant SaaS at `https://api.hf.app`
- **Self-hosted** -- Run the full stack in your own infrastructure

Both models expose the same REST API surface. All endpoints documented here
work identically in either deployment.

### Open standards

- All request and response bodies are **JSON** (`application/json`).
- Dates are **ISO 8601** strings in UTC.
- IDs are **UUIDs** (v4) unless otherwise noted.
- The API follows REST conventions with standard HTTP status codes.

---

## Quick Start

Get up and running in three steps.

### 1. Get your API key

```bash
# From the HF Dashboard: Settings > API Keys > Create Key
export HF_API_KEY="hf_live_xxxxxxxxxxxxxxxxxxxx"
```

### 2. Create a caller and submit a call

```bash
# Create a new caller
curl -s -X POST https://api.hf.app/api/v1/callers \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alex Johnson",
    "externalId": "user-42"
  }' | jq .

# Submit a call transcript for analysis
curl -s -X POST https://api.hf.app/api/v1/calls \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "callerId": "<CALLER_ID>",
    "transcript": "Hello, I would like to learn about...",
    "metadata": { "source": "api", "duration": 120 }
  }' | jq .
```

### 3. Run the pipeline and compose a prompt

```bash
# Trigger analysis pipeline on the call
curl -s -X POST https://api.hf.app/api/v1/pipeline/extract \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "callId": "<CALL_ID>"
  }' | jq .

# Compose a personalised prompt for the caller
curl -s -X POST https://api.hf.app/api/v1/callers/<CALLER_ID>/compose-prompt \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "playbookSlug": "companion"
  }' | jq .
```

The composed prompt includes personality context, memories, and
behaviour-specific instructions -- ready to pass to any LLM.

### What happens under the hood

```
Transcript ──> Pipeline EXTRACT ──> Personality scores
                                ──> Memories extracted
                                ──> Learning style detected
                                        │
                           Compose Prompt ◄──┘
                                │
                     Personalised system prompt
                      ready for your LLM call
```

---

## Authentication

All API requests must include a valid API key in the `Authorization` header.

```
Authorization: Bearer hf_live_xxxxxxxxxxxxxxxxxxxx
```

### Obtaining an API key

1. Log in to the HF Dashboard.
2. Navigate to **Settings > API Keys**.
3. Click **Create Key**, select the required scopes, and copy the key.

API keys are shown **once** at creation time. Store them securely.

### Key types

| Prefix | Environment | Purpose |
|--------|------------|---------|
| `hf_live_` | Production | Live traffic, metered usage |
| `hf_test_` | Sandbox | Development and testing, no billing |

### Scopes

Each key is issued with one or more scopes that control access:

| Scope | Grants |
|-------|--------|
| `callers:read` | List and retrieve caller profiles |
| `callers:write` | Create, update, and delete callers |
| `calls:read` | Retrieve call transcripts and analysis results |
| `calls:write` | Submit new calls and trigger pipeline processing |
| `pipeline:execute` | Execute the analysis pipeline directly |
| `prompts:read` | Compose and retrieve prompts |
| `specs:read` | List and retrieve analysis specifications |
| `specs:write` | Create and modify specifications |
| `playbooks:read` | List and retrieve playbooks |
| `playbooks:write` | Create and modify playbooks |
| `webhooks:manage` | Register and manage webhook endpoints |
| `admin` | Full access (use with caution) |

### Webhook signature verification

Outbound webhook payloads include an `X-HF-Signature` header containing an
HMAC-SHA256 signature. Verify it against your webhook secret:

```bash
EXPECTED=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | awk '{print $2}')
if [ "$EXPECTED" = "$RECEIVED_SIGNATURE" ]; then
  echo "Valid"
fi
```

### Error responses

Authentication failures return one of:

| Status | Meaning |
|--------|---------|
| `401 Unauthorized` | Missing or invalid API key |
| `403 Forbidden` | Valid key but insufficient scopes |
| `429 Too Many Requests` | Rate limit exceeded (see [Rate Limits](#rate-limits)) |

---

## Rate Limits

All API keys are subject to rate limiting. Limits vary by plan tier.

### Tiers

| Tier | Requests / minute | Burst | Pipeline calls / hour |
|------|-------------------|-------|-----------------------|
| **Free** | 60 | 10 | 20 |
| **Pro** | 600 | 50 | 200 |
| **Enterprise** | 6,000 | 500 | 2,000 |
| **Self-hosted** | Unlimited | -- | Unlimited |

### Response headers

Every response includes rate-limit headers:

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests per window |
| `X-RateLimit-Remaining` | Requests remaining in current window |
| `X-RateLimit-Reset` | UTC epoch seconds when the window resets |
| `Retry-After` | Seconds to wait (only present on `429` responses) |

### Handling 429 responses

When you exceed the limit, the API returns:

```json
{
  "ok": false,
  "error": "Rate limit exceeded",
  "retryAfter": 12
}
```

Best practices:

1. **Respect `Retry-After`** -- wait the indicated number of seconds.
2. **Use exponential back-off** -- if retries continue to fail, double the wait each attempt.
3. **Batch where possible** -- use bulk endpoints to reduce call count.
4. **Cache responses** -- caller profiles and specs change infrequently.

---

## Common Patterns

### Response envelope

All responses use a consistent JSON envelope:

```json
{
  "ok": true,
  "data": { ... },
  "message": "Optional human-readable message"
}
```

Error responses:

```json
{
  "ok": false,
  "error": "Short error description",
  "details": "Extended information (development mode only)"
}
```

### Pagination

List endpoints support cursor-based pagination:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | number | 100 | Items per page (max 500) |
| `offset` | number | 0 | Number of items to skip |

Response includes totals:

```json
{
  "ok": true,
  "callers": [ ... ],
  "total": 342,
  "limit": 100,
  "offset": 0
}
```

### Filtering

Many list endpoints accept query-string filters:

```bash
# Filter callers by domain
GET /api/v1/callers?domainId=abc-123&withCounts=true

# Filter calls by date range
GET /api/v1/calls?since=2026-01-01T00:00:00Z&until=2026-02-01T00:00:00Z
```

### Error codes

| Status | Meaning |
|--------|---------|
| `200` | Success |
| `201` | Created |
| `400` | Bad request -- check your parameters |
| `401` | Unauthorized -- missing or invalid API key |
| `403` | Forbidden -- insufficient scopes |
| `404` | Not found -- resource does not exist |
| `409` | Conflict -- resource already exists |
| `422` | Unprocessable -- validation failed |
| `429` | Rate limited -- slow down |
| `500` | Internal error -- contact support |

### Idempotency

POST endpoints that create resources accept an optional `Idempotency-Key`
header. If you send the same key within 24 hours, the API returns the
original response without creating a duplicate.

```bash
curl -X POST https://api.hf.app/api/v1/callers \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Idempotency-Key: req-abc-123" \
  -H "Content-Type: application/json" \
  -d '{"name": "Alex"}'
```

---

## API Reference

## Account

### `GET` /api/v1/account

Get the authenticated user's own profile

**Auth**: Session · **Scope**: `account:read`

**Response** `200`
```json
{ ok: true, user: object }
```

---

### `PATCH` /api/v1/account

Update the authenticated user's profile (display name, name, avatar initials)

**Auth**: Session · **Scope**: `account:write`

**Response** `200`
```json
{ ok: true, user: object }
```

---

## Callers

### `GET` /api/v1/callers

List all callers with optional memory/call counts. Returns paginated results ordered by creation date descending, with flattened domain and personality data.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| withCounts | query | boolean | No | When "true", fetches active memory and call counts per caller |
| includeArchived | query | boolean | No | When "true", includes archived callers (default false) |
| role | query | string | No | Filter by caller role (LEARNER, TEACHER, TUTOR, PARENT, MENTOR) |
| limit | query | number | No | Maximum callers to return (default 100, max 500) |
| offset | query | number | No | Number of callers to skip for pagination (default 0) |

**Response** `200`
```json
{ ok: true, callers: Caller[], total: number, limit: number, offset: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch callers" }
```

---

### `POST` /api/v1/callers

Create a new caller. Auto-assigns the default domain if none specified. Generates a playground externalId.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| name | body | string | No | Caller name (required) |
| email | body | string | No | Caller email (optional) |
| phone | body | string | No | Caller phone number (optional) |
| domainId | body | string | No | Domain ID to assign (optional, defaults to system default domain) |
| role | body | string | No | Caller role (optional, default LEARNER) |

**Response** `200`
```json
{ ok: true, caller: { id, name, email, phone, role, domain } }
```

**Response** `400`
```json
{ ok: false, error: "Name is required" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to create caller" }
```

---

### `DELETE` /api/v1/callers/:callerId

Delete a caller and all associated data. Optionally exclude their identifiers from future imports.

**Auth**: Session · **Scope**: `callers:delete`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to delete |
| exclude | body | boolean | No | Add phone/externalId to ExcludedCaller table (default: false) |

**Response** `200`
```json
{ ok: true, message: string, excluded: boolean }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

### `GET` /api/v1/callers/:callerId

Get comprehensive caller data including profile, personality, memories, calls, scores, goals, curriculum, and learner profile

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, caller: object, personalityProfile: object, observations: Array, memories: Array, memorySummary: object, calls: Array, identities: Array, scores: Array, callerTargets: Array, curriculum: object, learnerProfile: object, goals: Array, counts: object }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

### `PATCH` /api/v1/callers/:callerId

Update caller profile fields. Domain changes trigger goal archival and new goal creation from playbook.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |
| name | body | string | No | Caller display name |
| email | body | string | No | Caller email |
| phone | body | string | No | Caller phone number |
| domainId | body | string | No | New domain ID (triggers domain switch if different) |
| role | body | string | No | Caller role (LEARNER, TEACHER, TUTOR, PARENT, MENTOR) |
| archive | body | boolean | No | Set true to archive, false to unarchive |

**Response** `200`
```json
{ ok: true, caller: object, goalsCreated?: string[] }
```

**Response** `400`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

### `GET` /api/v1/callers/:callerId/actions

List call actions for a caller. Optionally filter by status, assignee, or callId.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, actions: CallAction[], counts: { pending, completed, total } }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

---

### `POST` /api/v1/callers/:callerId/actions

Create a manual action for a caller (operator drops something in).

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `201`
```json
{ ok: true, action: CallAction }
```

**Response** `400`
```json
{ ok: false, error: string }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

---

### `DELETE` /api/v1/callers/:callerId/actions/:actionId

Delete a call action.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |
| actionId | path | string | Yes | The action ID |

**Response** `200`
```json
{ ok: true }
```

**Response** `404`
```json
{ ok: false, error: string }
```

---

### `PATCH` /api/v1/callers/:callerId/actions/:actionId

Update a call action (status, notes, assignee, priority, dueAt).

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |
| actionId | path | string | Yes | The action ID |

**Response** `200`
```json
{ ok: true, action: CallAction }
```

**Response** `404`
```json
{ ok: false, error: string }
```

---

### `GET` /api/v1/callers/:callerId/aggregate

Get available AGGREGATE specs for a caller. Returns all active specs with outputType AGGREGATE that can be run.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to query aggregate specs for |

**Response** `200`
```json
{ ok: true, callerId: string, availableSpecs: { slug: string, name: string, description: string }[] }
```

**Response** `500`
```json
{ ok: false, error: "Failed to get aggregate specs" }
```

---

### `POST` /api/v1/callers/:callerId/aggregate

Run all active AGGREGATE specs to compute derived attributes from measurements for a caller. Finds active AGGREGATE specs, reads aggregationRules from spec config, queries recent CallScores for source parameters, applies aggregation logic (thresholds, averages), and updates CallerAttribute (e.g., learner profile).

**Auth**: Session · **Scope**: `pipeline:execute`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to run aggregation for |

**Response** `200`
```json
{ ok: true, callerId: string, specsRun: number, profileUpdates: object[], errors: string[], timestamp: string }
```

**Response** `500`
```json
{ ok: false, error: "Failed to run aggregate specs" }
```

---

### `GET` /api/v1/callers/:callerId/artifacts

List conversation artifacts for a caller. Optionally filter by callId or status.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, artifacts: ConversationArtifact[] }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

---

### `POST` /api/v1/callers/:callerId/calls

Create a new call record for a caller. Auto-determines call sequence number if not provided. Links to previous call for chain tracking.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to create a call for |
| source | body | string | No | Call source identifier (default: "ai-simulation") |
| callSequence | body | number | No | Explicit sequence number (optional, auto-incremented if omitted) |
| transcript | body | string | No | Call transcript text (default: "") |

**Response** `200`
```json
{ ok: true, call: { id, callSequence, source, createdAt } }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to create call" }
```

---

### `GET` /api/v1/callers/:callerId/compose-prompt

Get composed prompt history for a caller. Returns prompts ordered by composition date descending, with optional status filtering.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to fetch prompt history for |
| limit | query | number | No | Maximum prompts to return (default 20) |
| status | query | string | No | Filter by status: "active", "superseded", or "all" (default: all) |

**Response** `200`
```json
{ ok: true, prompts: ComposedPrompt[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch prompts" }
```

---

### `POST` /api/v1/callers/:callerId/compose-prompt

Compose a personalized next-call prompt for a caller using the declarative composition pipeline driven by COMP-001 spec sections. Loads caller data, applies section transformations, renders a deterministic prompt summary, stores the result, and supersedes previous active prompts.

**Auth**: Session · **Scope**: `callers:compose`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to compose a prompt for |
| triggerType | body | string | No | What triggered this composition (default: "manual") |
| triggerCallId | body | string | No | Optional call ID that triggered this composition |
| targetOverrides | body | object | No | Preview overrides for behavior targets (not persisted) |

**Response** `200`
```json
{ ok: true, prompt: ComposedPrompt, metadata: { engine, model, usage, inputContext, composition } }
```

**Response** `500`
```json
{ ok: false, error: "Failed to compose prompt" }
```

---

### `GET` /api/v1/callers/:callerId/enrollments

List all playbook enrollments for a caller.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, enrollments: CallerPlaybook[] }
```

---

### `POST` /api/v1/callers/:callerId/enrollments

Enroll a caller in a playbook.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |
| playbookId | body | string | No | Playbook to enroll in (required) |

**Response** `200`
```json
{ ok: true, enrollment: CallerPlaybook }
```

**Response** `400`
```json
{ ok: false, error: "playbookId is required" }
```

---

### `GET` /api/v1/callers/:callerId/exam-readiness

Compute exam readiness for a caller across all active curricula (or one specific)

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, curricula: ExamReadinessResult[] }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

---

### `POST` /api/v1/callers/:callerId/exam-readiness

Submit formative assessment results or record an exam result

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, readiness: ExamReadinessResult }
```

**Response** `400`
```json
{ ok: false, error: string }
```

---

### `POST` /api/v1/callers/:callerId/reset

Reset all analysis data for a caller while preserving source calls/transcripts. Deletes CallScores, BehaviorMeasurements, RewardScores, PromptSlugSelections, CallerMemory, CallerMemorySummary, PersonalityObservations, CallerPersonality, CallerPersonalityProfile, ComposedPrompts, CallTargets, CallerTargets, and CALLER-scoped BehaviorTargets. Clears CallerIdentity fields and resets call sequence numbers. Preserves Caller record, Call records (transcripts), and CallerIdentity structure.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to reset analysis data for |

**Response** `200`
```json
{ ok: true, message: string, deleted: { scores, behaviorMeasurements, rewardScores, callTargets, slugSelections, memories, memorySummary, observations, personalityProfiles, personality, prompts, callerTargets, behaviorTargets, identitiesCleared, callSequencesReset, callsPreserved } }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to reset caller" }
```

---

### `GET` /api/v1/callers/:callerId/slugs

Returns all resolved template variables/slugs for a specific caller as a hierarchical tree. Shows values currently available for prompt composition including Identity/Content/Voice from playbook specs, Memories from LEARN specs, Scores from MEASURE specs, and Personalized targets from ADAPT specs. Also identifies template variables that are defined but not yet populated.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to fetch slugs for |

**Response** `200`
```json
{ ok: true, caller: { id, name, domain }, playbook: { id, name, status } | null, tree: SlugNode[], counts: { memories, scores, targets, available, total } }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch caller slugs" }
```

---

### `GET` /api/v1/callers/:callerId/snapshot

Download a complete snapshot of a caller's analysis state as a JSON file attachment. Includes caller profile, personality data (aggregate, profiles, observations), all memories, all call scores, calls with transcripts, caller identities, composed prompts, playbook info, and summary statistics. Useful for comparing analysis results across playbook configurations, archiving before reset, and debugging/auditing.

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID to snapshot |
| includeTranscripts | query | boolean | No | Whether to include call transcripts (default: true, set to "false" to exclude) |
| label | query | string | No | Optional label to include in the snapshot metadata and filename |

**Response** `200`
```json
application/json attachment: { _meta, summary, caller, personality, memory, calls, identities, composedPrompts }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to create snapshot" }
```

---

### `GET` /api/v1/callers/:callerId/trust-progress

Compute trust-weighted progress for a caller across all active curricula

**Auth**: Session · **Scope**: `callers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | The caller ID |

**Response** `200`
```json
{ ok: true, curricula: TrustProgressEntry[] }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

### `POST` /api/v1/callers/merge

Merge multiple source callers into a single target caller. Moves all data (calls, memories, observations, scores, identities, composed prompts, slug selections) from source callers to the target. Handles unique constraints by merging personality, personality profiles, memory summaries, caller targets, and caller attributes using weighted averages. Re-sequences calls chronologically. Deletes source callers after merge.

**Auth**: Session · **Scope**: `callers:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| targetCallerId | body | string | No | The caller ID that will receive all merged data (required) |

**Response** `200`
```json
{ ok: true, message: string, merged: { calls, memories, observations, scores, identities, composedPrompts, callerTargets, attributes, promptSlugSelections, personality, personalityProfile, memorySummary }, deletedCallers: number, targetCaller: { id, name, email } }
```

**Response** `400`
```json
{ ok: false, error: "Target caller ID required" }
```

**Response** `400`
```json
{ ok: false, error: "At least one source caller required" }
```

**Response** `400`
```json
{ ok: false, error: "Target caller cannot be in source list" }
```

**Response** `404`
```json
{ ok: false, error: "Callers not found: ..." }
```

**Response** `500`
```json
{ ok: false, error: "Failed to merge callers" }
```

---

## Calls

### `GET` /api/v1/calls

List calls with optional filtering by caller. Returns calls with scores, memories, behavior measurements, triggered prompts, and pipeline status.

**Auth**: Session · **Scope**: `calls:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| limit | query | number | No | Max number of calls to return (default: 100) |
| callerId | query | string | No | Filter calls by caller ID |

**Response** `200`
```json
{ ok: true, calls: Call[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch calls" }
```

---

### `GET` /api/v1/calls/:callId

Get detailed call data including basic call info, scores with parameter details, extracted memories, behavior measurements, reward score, triggered prompts, personality observation, and effective behavior targets (layered: SYSTEM -> PLAYBOOK -> SEGMENT -> CALLER).

**Auth**: Session · **Scope**: `calls:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callId | path | string | Yes | The call ID to retrieve |

**Response** `200`
```json
{ ok: true, call: Call, scores: CallScore[], memories: CallerMemory[], measurements: BehaviorMeasurement[], rewardScore: RewardScore | null, triggeredPrompts: ComposedPrompt[], personalityObservation: PersonalityObservation | null, effectiveTargets: EffectiveTarget[], counts: { scores, memories, measurements, prompts, targets } }
```

**Response** `404`
```json
{ ok: false, error: "Call not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch call" }
```

---

### `PATCH` /api/v1/calls/:callId

Update call data (e.g., transcript or summary after AI simulation). Only provided fields are updated.

**Auth**: Session · **Scope**: `calls:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callId | path | string | Yes | The call ID to update |
| transcript | body | string | No | Updated call transcript (optional) |
| summary | body | string | No | Updated call summary (optional) |

**Response** `200`
```json
{ ok: true, call: Call }
```

**Response** `404`
```json
{ ok: false, error: "Call not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to update call" }
```

---

### `POST` /api/v1/calls/:callId/end

End a call by running the full pipeline (mode="prompt") and composing the next prompt. Internally delegates to the pipeline endpoint.

**Auth**: Session · **Scope**: `calls:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callId | path | string | Yes | The call ID to end and process |
| engine | body | string | No | AI engine to use: "mock" | "claude" | "openai" (default: "claude") |

**Response** `200`
```json
{ ok: true, pipeline: { scoresCreated, memoriesCreated, measurementsCreated, callTargetsCreated, playbookUsed }, prompt: { composed: boolean, id?: string, length?: number, error?: string } }
```

**Response** `404`
```json
{ ok: false, error: "Call not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to end call" }
```

---

### `POST` /api/v1/calls/:callId/ops/:opId

Run a specific analysis op on a single call. Valid ops: measure, learn, measure-agent, reward, adapt. Returns result with detailed logs for debugging.

**Auth**: Session · **Scope**: `calls:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callId | path | string | Yes | The call ID to run the op on |
| opId | path | string | Yes | The op to run: "measure" | "learn" | "measure-agent" | "reward" | "adapt" |
| callerId | body | string | No | The caller ID (required) |
| engine | body | string | No | AI engine to use: "mock" | "claude" | "openai" (default: "claude") |

**Response** `200`
```json
{ ok: true, message: string, data: object, logs: LogEntry[], duration: number }
```

**Response** `400`
```json
{ ok: false, error: "callerId is required" | "Unknown op: ...", logs: LogEntry[], duration: number }
```

**Response** `500`
```json
{ ok: false, error: string, logs: LogEntry[], duration: number }
```

---

### `POST` /api/v1/calls/:callId/pipeline

SPEC-DRIVEN pipeline endpoint that runs analysis in configurable stages. Pipeline stages are loaded from the PIPELINE-001 spec (or GUARD-001 fallback), not hardcoded. Each stage has a name, order, outputTypes, and optional requiresMode. Default stages: EXTRACT (10), SCORE_AGENT (20), AGGREGATE (30), REWARD (40), ADAPT (50), SUPERVISE (60), COMPOSE (100, prompt mode only).

**Auth**: Session · **Scope**: `pipeline:execute`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callId | path | string | Yes | The call ID to run the pipeline on |
| callerId | body | string | No | The caller ID (required) |
| mode | body | string | No | Pipeline mode: "prep" (all stages except COMPOSE) or "prompt" (all stages including COMPOSE) (required) |
| engine | body | string | No | AI engine to use: "mock" | "claude" | "openai" (default: "claude") |

**Response** `200`
```json
{ ok: true, mode: "prep" | "prompt", message: string, data: { scoresCreated, memoriesCreated, callTargetsCreated, agentMeasurements, ... }, prompt?: object, logs: LogEntry[], duration: number }
```

**Response** `400`
```json
{ ok: false, error: "callerId is required" | "mode must be 'prep' or 'prompt'", logs: LogEntry[] }
```

**Response** `404`
```json
{ ok: false, error: "Call not found", logs: LogEntry[] }
```

**Response** `500`
```json
{ ok: false, error: string, logs: LogEntry[], duration: number }
```

---

### `GET` /api/v1/calls/rewards

List reward scores across all calls, ordered by most recent. Includes associated call source and transcript.

**Auth**: Session · **Scope**: `calls:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| limit | query | number | No | Max number of reward scores to return (default: 100) |

**Response** `200`
```json
{ ok: true, scores: RewardScore[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch reward scores" }
```

---

### `GET` /api/v1/calls/scores

List call scores across all calls, ordered by most recent. Includes parameter details, call source/transcript, and run status.

**Auth**: Session · **Scope**: `calls:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| limit | query | number | No | Max number of scores to return (default: 100) |

**Response** `200`
```json
{ ok: true, scores: CallScore[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch call scores" }
```

---

## Cohorts

### `GET` /api/v1/callers/:callerId/cohorts

List cohort groups owned by a caller (teacher/tutor).

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | path | string | Yes | Caller ID (the teacher/tutor) |

**Response** `200`
```json
{ ok: true, cohorts: CohortGroup[] }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch cohorts" }
```

---

### `GET` /api/v1/cohorts

List cohort groups. Admins see all; teachers see only owned cohorts.

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | query | string | No | Filter by domain (optional) |
| ownerId | query | string | No | Filter by owner caller ID (optional) |
| isActive | query | boolean | No | Filter by active status (optional, default true) |
| limit | query | number | No | Max results (default 100, max 500) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok: true, cohorts: CohortGroup[], total: number, limit: number, offset: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch cohorts" }
```

---

### `POST` /api/v1/cohorts

Create a new cohort group. The authenticated user's linked caller becomes the owner.

**Auth**: Session · **Scope**: `cohorts:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| name | body | string | No | Cohort name (required) |
| description | body | string | No | Cohort description (optional) |
| domainId | body | string | No | Domain ID (required) |
| ownerId | body | string | No | Owner caller ID (optional, defaults to user's linked caller) |
| maxMembers | body | number | No | Maximum member count (optional, default 50) |

**Response** `200`
```json
{ ok: true, cohort: CohortGroup }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `500`
```json
{ ok: false, error: "Failed to create cohort" }
```

---

### `DELETE` /api/v1/cohorts/:cohortId

Delete a cohort group. Removes member assignments first, then deletes the group.

**Auth**: Session · **Scope**: `cohorts:delete`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, message: "Cohort deleted" }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to delete cohort" }
```

---

### `GET` /api/v1/cohorts/:cohortId

Get cohort detail with member list.

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, cohort: CohortGroup, members: Caller[] }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch cohort" }
```

---

### `PATCH` /api/v1/cohorts/:cohortId

Update cohort name, description, maxMembers, or isActive.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |
| name | body | string | No | New name (optional) |
| description | body | string | No | New description (optional) |
| maxMembers | body | number | No | New max member count (optional) |
| isActive | body | boolean | No | Active status (optional) |

**Response** `200`
```json
{ ok: true, cohort: CohortGroup }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to update cohort" }
```

---

### `GET` /api/v1/cohorts/:cohortId/activity

Recent activity feed for a cohort. Returns calls, goal updates, and

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |
| limit | query | number | No | Maximum items to return (default 50, max 200) |
| offset | query | number | No | Number of items to skip (default 0) |

**Response** `200`
```json
{ ok: true, activity, total, limit, offset }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch activity" }
```

---

### `GET` /api/v1/cohorts/:cohortId/dashboard

Aggregated dashboard stats for a cohort. Returns per-pupil call counts,

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, cohort, summary, pupils }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch dashboard" }
```

---

### `GET` /api/v1/cohorts/:cohortId/invite

List pending invites for a cohort.

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, invites }
```

---

### `POST` /api/v1/cohorts/:cohortId/invite

Send email invites to pupils for this cohort. Creates Invite records

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, created, skipped, sent }
```

**Response** `400`
```json
{ ok: false, error: string }
```

---

### `DELETE` /api/v1/cohorts/:cohortId/join-link

Revoke the magic join link for a cohort.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, message: "Join link revoked" }
```

---

### `GET` /api/v1/cohorts/:cohortId/join-link

Get the magic join link for a cohort. Generates one if none exists.

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, joinToken }
```

---

### `POST` /api/v1/cohorts/:cohortId/join-link

Regenerate the magic join link for a cohort.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, joinToken }
```

---

### `DELETE` /api/v1/cohorts/:cohortId/members

Remove callers from a cohort group. Deletes their CallerCohortMembership record.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, removed: number }
```

**Response** `400`
```json
{ ok: false, error: "callerIds array is required" }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to remove members" }
```

---

### `POST` /api/v1/cohorts/:cohortId/members

Add callers to a cohort group. Validates all callers exist and belong to the same domain.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, added: number }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to add members" }
```

---

### `GET` /api/v1/cohorts/:cohortId/playbooks

List playbooks assigned to a cohort and available domain playbooks not yet assigned.

**Auth**: Session · **Scope**: `cohorts:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, playbooks: CohortPlaybook[], available: Playbook[] }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

---

### `POST` /api/v1/cohorts/:cohortId/playbooks

Assign one or more playbooks to a cohort. Optionally auto-enroll existing cohort members.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |
| autoEnrollMembers | body | boolean | No | Whether to auto-enroll existing members (default: false) |

**Response** `200`
```json
{ ok: true, assigned: number, enrolled: number }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

---

### `DELETE` /api/v1/cohorts/:cohortId/playbooks/:playbookId

Remove a playbook from a cohort. Optionally drop member enrollments.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |
| playbookId | path | string | Yes | Playbook ID to remove |
| dropEnrollments | query | boolean | No | Whether to drop member enrollments (default: false) |

**Response** `200`
```json
{ ok: true, removed: true, dropped: number }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

---

### `POST` /api/v1/cohorts/:cohortId/playbooks/sync

Sync all cohort members to the cohort's assigned playbooks. Enrolls any members missing enrollments.

**Auth**: Session · **Scope**: `cohorts:update`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| cohortId | path | string | Yes | Cohort group ID |

**Response** `200`
```json
{ ok: true, synced: number, errors: string[] }
```

**Response** `404`
```json
{ ok: false, error: "Cohort not found" }
```

---

## Communities

### `GET` /api/v1/communities

List all communities (Domains with kind=COMMUNITY)

**Auth**: Session · **Scope**: `communities:read`

**Response** `200`
```json
{ ok: true, communities: Domain[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/communities/[communityId]

Archive a community (soft delete)

**Auth**: Session · **Scope**: `communities:write`

**Response** `200`
```json
{ ok: true, message: "Community archived" }
```

**Response** `404`
```json
{ ok: false, error: "Community not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/communities/[communityId]

Get a single community detail with identity specs, onboarding config, and members

**Auth**: Session · **Scope**: `communities:read`

**Response** `200`
```json
{ ok: true, community: { id, name, slug, description, onboardingWelcome, onboardingIdentitySpecId, onboardingFlowPhases, onboardingDefaultTargets, memberCount, playbookCount, personaName, identitySpec, identitySpecs, members } }
```

**Response** `404`
```json
{ ok: false, error: "Community not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PATCH` /api/v1/communities/[communityId]

Update a community — name, description, welcome message, identity spec, flow phases, default targets

**Auth**: Session · **Scope**: `communities:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| name | body | string | No | Community name |
| description | body | string | No | Community description |
| onboardingWelcome | body | string | No | Welcome message for first call |
| onboardingIdentitySpecId | body | string | No | Identity spec ID for the AI persona |
| onboardingFlowPhases | body | object | No | Flow phases configuration |
| onboardingDefaultTargets | body | object | No | Default behavior targets (includes _matrixPositions for round-trip) |

**Response** `200`
```json
{ ok: true, community: Domain }
```

**Response** `404`
```json
{ ok: false, error: "Community not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/communities/[communityId]/members

Add a caller to a community by setting their domainId

**Auth**: Session · **Scope**: `communities:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | body | string | No | Caller ID to add |

**Response** `200`
```json
{ ok: true, member: { id, name, email } }
```

**Response** `400`
```json
{ ok: false, error: "callerId is required" }
```

**Response** `404`
```json
{ ok: false, error: "Community not found" }
```

**Response** `409`
```json
{ ok: false, error: "Caller is already a member" }
```

---

### `DELETE` /api/v1/communities/[communityId]/members/[callerId]

Remove a caller from a community by clearing their domainId

**Auth**: Session · **Scope**: `communities:write`

**Response** `200`
```json
{ ok: true }
```

**Response** `404`
```json
{ ok: false, error: "Community not found" | "Member not found" }
```

---

## Content Trust

### `GET` /api/v1/content-sources/:sourceId

Get a content source by ID, including assertion count and freshness status

**Auth**: Session · **Scope**: `content-sources:read`

---

### `PATCH` /api/v1/content-sources/:sourceId

Update a content source. Trust level changes are validated and logged.

**Auth**: Session · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| trustLevel | body | ContentTrustLevel | No | New trust level (optional) |
| verificationNotes | body | string | No | Notes explaining the trust level change (required when changing trust) |
| name | body | string | No | Updated name (optional) |
| description | body | string | No | Updated description (optional) |
| validUntil | body | string | No | Updated expiry date (optional) |
| isActive | body | boolean | No | Active status (optional) |
| supersededById | body | string | No | ID of newer source that replaces this one (optional) |

---

### `GET` /api/v1/content-sources/:sourceId/assertions

List assertions for a content source with optional filtering, sorting, and review status.

**Auth**: Session · **Scope**: `content-sources:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |
| category | query | string | No | Filter by category (fact, definition, threshold, rule, process, example) |
| search | query | string | No | Search assertion text (case-insensitive) |
| limit | query | number | No | Max results (default 50, max 500) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok: true, assertions: ContentAssertion[], total: number, reviewed: number, reviewProgress: number }
```

---

### `DELETE` /api/v1/content-sources/:sourceId/assertions/:assertionId

Delete an individual content assertion. Refuses if assertion has children in the hierarchy.

**Auth**: session (ADMIN+) · **Scope**: `content-sources:delete`

**Response** `200`
```json
{ ok: true, deleted: { id: string } }
```

**Response** `400`
```json
{ ok: false, error: "Cannot delete assertion with children" }
```

**Response** `404`
```json
{ ok: false, error: "Assertion not found" }
```

---

### `PATCH` /api/v1/content-sources/:sourceId/assertions/:assertionId

Update an individual content assertion. Can modify text, category, tags, location,

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| assertion | body | string | No | Updated assertion text (5-5000 chars) |
| category | body | string | No | Category (fact, definition, threshold, rule, process, example) |
| markReviewed | body | boolean | No | When true, sets reviewedBy/reviewedAt from session |

**Response** `200`
```json
{ ok: true, assertion: ContentAssertion }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Assertion not found" }
```

---

### `POST` /api/v1/content-sources/:sourceId/assertions/bulk-review

Mark multiple assertions as reviewed in a single transaction.

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

**Response** `200`
```json
{ ok: true, updated: number }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/content-sources/:sourceId/extract

Trigger extraction for a classified content source.

**Auth**: OPERATOR · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes | ContentSource UUID |
| subjectId | body | string | No | Optional Subject UUID (for auto-trigger curriculum check; omit for orphan sources) |
| text | body | string | No | Optional pre-extracted text (if not provided, downloads from linked media asset) |

**Response** `202`
```json
{ ok, jobId, totalChunks }
```

**Response** `400`
```json
{ ok: false, error }
```

**Response** `404`
```json
{ ok: false, error }
```

---

### `POST` /api/v1/content-sources/:sourceId/import

Upload a document (PDF, text, markdown) and extract ContentAssertions linked to this source.

**Auth**: Session · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| file | body | File | No | The document to parse (multipart/form-data) |
| focusChapters | body | string | No | Comma-separated chapter names to focus on (optional) |
| maxAssertions | body | number | No | Max assertions to extract (default: 500) |

**Response** `202`
```json
{ ok: true, taskId: string } (classify mode - async)
```

**Response** `200`
```json
{ ok: true, assertions: ExtractedAssertion[], created: number, duplicatesSkipped: number, warnings: string[] }
```

**Response** `202`
```json
{ ok: true, jobId: string } (background mode)
```

---

### `GET` /api/v1/content-sources/:sourceId/import?jobId=xxx

Poll the status of a background extraction job.

**Auth**: Session · **Scope**: `content-sources:read`

---

### `POST` /api/v1/content-sources/:sourceId/lesson-plan

Generate a lesson plan from a content source's assertions, questions, and vocabulary.

**Auth**: OPERATOR · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |
| sessionLength | body | number | No | Target minutes per session (default 30) |
| includeAssessment | body | boolean | No | Include assessment session (default true) |
| includeReview | body | boolean | No | Include review session (default true) |

**Response** `200`
```json
{ ok, plan }
```

---

### `DELETE` /api/v1/content-sources/:sourceId/questions

Delete all questions for a content source (for re-extraction).

**Auth**: OPERATOR · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |

**Response** `200`
```json
{ ok, deleted }
```

---

### `GET` /api/v1/content-sources/:sourceId/questions

List extracted questions for a content source with filtering.

**Auth**: Session · **Scope**: `content-sources:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |
| questionType | query | string | No | Filter by type (MCQ, TRUE_FALSE, MATCHING, etc.) |
| search | query | string | No | Search question text (case-insensitive) |
| reviewed | query | string | No | Filter by review status ("true" or "false") |
| limit | query | number | No | Max results (default 50, max 500) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok, questions, total, reviewedCount, reviewProgress }
```

---

### `DELETE` /api/v1/content-sources/:sourceId/questions/:questionId

Delete an individual content question.

**Auth**: session (ADMIN+) · **Scope**: `content-sources:delete`

**Response** `200`
```json
{ ok: true, deleted: { id: string } }
```

**Response** `404`
```json
{ ok: false, error: "Question not found" }
```

---

### `PATCH` /api/v1/content-sources/:sourceId/questions/:questionId

Update an individual content question. Can modify text, type, answer, options,

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| questionText | body | string | No | Updated question text (5-5000 chars) |
| questionType | body | string | No | Question type enum |
| markReviewed | body | boolean | No | When true, sets reviewedBy/reviewedAt from session |

**Response** `200`
```json
{ ok: true, question: ContentQuestion }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Question not found" }
```

---

### `POST` /api/v1/content-sources/:sourceId/questions/bulk-review

Mark multiple questions as reviewed in a single transaction.

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

**Response** `200`
```json
{ ok: true, updated: number }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/content-sources/:sourceId/vocabulary

Delete all vocabulary for a content source (for re-extraction).

**Auth**: OPERATOR · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |

**Response** `200`
```json
{ ok, deleted }
```

---

### `GET` /api/v1/content-sources/:sourceId/vocabulary

List extracted vocabulary for a content source with filtering.

**Auth**: Session · **Scope**: `content-sources:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sourceId | path | string | Yes |  |
| topic | query | string | No | Filter by topic |
| search | query | string | No | Search term or definition (case-insensitive) |
| reviewed | query | string | No | Filter by review status ("true" or "false") |
| limit | query | number | No | Max results (default 50, max 500) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok, vocabulary, total, reviewedCount, reviewProgress }
```

---

### `DELETE` /api/v1/content-sources/:sourceId/vocabulary/:vocabId

Delete an individual vocabulary entry.

**Auth**: session (ADMIN+) · **Scope**: `content-sources:delete`

**Response** `200`
```json
{ ok: true, deleted: { id: string } }
```

**Response** `404`
```json
{ ok: false, error: "Vocabulary entry not found" }
```

---

### `PATCH` /api/v1/content-sources/:sourceId/vocabulary/:vocabId

Update an individual vocabulary entry. Can modify term, definition, part of speech,

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| term | body | string | No | Updated term (1-500 chars) |
| definition | body | string | No | Updated definition (1-5000 chars) |
| markReviewed | body | boolean | No | When true, sets reviewedBy/reviewedAt from session |

**Response** `200`
```json
{ ok: true, vocabulary: ContentVocabulary }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Vocabulary entry not found" }
```

---

### `POST` /api/v1/content-sources/:sourceId/vocabulary/bulk-review

Mark multiple vocabulary entries as reviewed in a single transaction.

**Auth**: session (OPERATOR+) · **Scope**: `content-sources:write`

**Response** `200`
```json
{ ok: true, updated: number }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

---

## Curricula

### `GET` /api/v1/curricula/:curriculumId/lesson-plan

Get the lesson plan for a curriculum. Returns null if no plan exists.

**Auth**: session (VIEWER+) · **Scope**: `curricula:read`

**Response** `200`
```json
{ ok: true, plan: LessonPlan | null }
```

**Response** `404`
```json
{ ok: false, error: "Curriculum not found" }
```

---

### `POST` /api/v1/curricula/:curriculumId/lesson-plan

Start AI-generation of a lesson plan from curriculum modules. Returns 202 with taskId to poll for progress.

**Auth**: session (OPERATOR+) · **Scope**: `curricula:write`

**Response** `202`
```json
{ ok: true, taskId: string }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Curriculum not found" }
```

---

### `PUT` /api/v1/curricula/:curriculumId/lesson-plan

Save or update the lesson plan. Validates session numbers and types.

**Auth**: session (OPERATOR+) · **Scope**: `curricula:write`

**Response** `200`
```json
{ ok: true, plan: LessonPlan }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Curriculum not found" }
```

---

## Domains

### `GET` /api/v1/domains

List all domains with caller counts and playbook info

**Auth**: Session · **Scope**: `domains:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| includeInactive | query | boolean | No | Include inactive domains (default: false) |
| onlyInstitution | query | boolean | No | Only return domains linked to an institution (default: false) |

**Response** `200`
```json
{ ok: true, domains: Domain[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/domains

Create a new domain

**Auth**: Session · **Scope**: `domains:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| slug | body | string | No | Unique domain slug |
| name | body | string | No | Display name |
| description | body | string | No | Optional description |
| isDefault | body | boolean | No | Set as default domain |
| institutionId | body | string | No | Optional institution ID to link this domain to |

**Response** `200`
```json
{ ok: true, domain: Domain }
```

**Response** `400`
```json
{ ok: false, error: "slug and name are required" }
```

**Response** `409`
```json
{ ok: false, error: "Domain with slug ... already exists" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/domains/:domainId

Soft-delete a domain by setting isActive = false. Blocks if domain is default or has callers.

**Auth**: Session · **Scope**: `domains:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | Domain UUID |

**Response** `200`
```json
{ ok: true, message: "Domain deactivated" }
```

**Response** `400`
```json
{ ok: false, error: "Cannot delete the default domain" }
```

**Response** `400`
```json
{ ok: false, error: "Cannot delete domain with N callers assigned..." }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/domains/:domainId

Get domain details with callers and playbooks

**Auth**: Session · **Scope**: `domains:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | Domain UUID |

**Response** `200`
```json
{ ok: true, domain: Domain }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PATCH` /api/v1/domains/:domainId

Update a domain's name, description, default status, or active status

**Auth**: Session · **Scope**: `domains:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | Domain UUID |
| name | body | string | No | Updated display name |
| description | body | string | No | Updated description |
| isDefault | body | boolean | No | Set as default domain |
| isActive | body | boolean | No | Enable or disable domain |

**Response** `200`
```json
{ ok: true, domain: Domain }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/domains/:domainId/course-readiness

Check if a course is content-ready for its first lesson. Evaluates checks defined in COURSE-READY-001 ORCHESTRATE spec. Returns structured pass/fail results with action links.

**Auth**: Session · **Scope**: `domains:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | The domain ID to check course readiness for |

**Response** `200`
```json
{ ok: true, domainId, ready, score, level, checks[], criticalPassed, criticalTotal, recommendedPassed, recommendedTotal }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

### `GET` /api/v1/domains/:domainId/extraction-config

Get merged extraction config for a domain (system + domain override).

**Auth**: Session · **Scope**: `domains:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | Domain UUID |

**Response** `200`
```json
{ ok: true, config: ExtractionConfig, hasOverride: boolean, overrideSpecId: string | null }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PUT` /api/v1/domains/:domainId/extraction-config

Set or clear the domain-level extraction config override.

**Auth**: Session · **Scope**: `domains:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | Domain UUID |

**Response** `200`
```json
{ ok: true, config: ExtractionConfig, hasOverride: boolean, overrideSpecId: string | null }
```

**Response** `400`
```json
{ ok: false, error: "Domain has no published playbook..." }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/domains/:domainId/readiness

Check if a domain is ready to receive calls. Evaluates checks defined in DOMAIN-READY-001 ORCHESTRATE spec. Returns structured pass/fail results with fix action links.

**Auth**: Session · **Scope**: `domains:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | path | string | Yes | The domain ID to check readiness for |

**Response** `200`
```json
{ ok: true, domainId, domainName, ready, score, level, checks[], criticalPassed, criticalTotal, recommendedPassed, recommendedTotal }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found: ..." }
```

**Response** `500`
```json
{ ok: false, error: string }
```

---

## Goals

### `GET` /api/v1/goals

Fetch all goals across all callers with filtering options. Includes related caller, playbook, and content spec data. Returns aggregate counts grouped by status and type.

**Auth**: Session · **Scope**: `goals:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| status | query | string | No | Filter by goal status (optional, "all" for no filter) |
| type | query | string | No | Filter by goal type (optional, "all" for no filter) |
| callerId | query | string | No | Filter by caller ID (optional) |

**Response** `200`
```json
{ ok: true, goals: [...], counts: { total, byStatus: {...}, byType: {...} } }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch goals" }
```

---

### `POST` /api/v1/goals

Create a new goal for a caller.

**Auth**: Session · **Scope**: `goals:write`

**Response** `201`
```json
{ ok: true, goal: Goal }
```

**Response** `400`
```json
{ ok: false, error: string }
```

---

### `DELETE` /api/v1/goals/:goalId

Delete a goal.

**Auth**: Session · **Scope**: `goals:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| goalId | path | string | Yes | The goal ID |

**Response** `200`
```json
{ ok: true }
```

**Response** `404`
```json
{ ok: false, error: string }
```

---

### `GET` /api/v1/goals/:goalId

Fetch a single goal with related caller, playbook, and content spec data.

**Auth**: Session · **Scope**: `goals:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| goalId | path | string | Yes | The goal ID |

**Response** `200`
```json
{ ok: true, goal: Goal }
```

**Response** `404`
```json
{ ok: false, error: string }
```

---

### `PATCH` /api/v1/goals/:goalId

Update a goal (name, description, type, status, priority, targetDate).

**Auth**: Session · **Scope**: `goals:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| goalId | path | string | Yes | The goal ID |

**Response** `200`
```json
{ ok: true, goal: Goal }
```

**Response** `400`
```json
{ ok: false, error: string }
```

**Response** `404`
```json
{ ok: false, error: string }
```

---

## Invites

### `POST` /api/v1/invite/accept

Accepts an invite: creates User account, marks invite used, sets session cookie for auto sign-in.

**Auth**: None

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| token | body | string | No | Invite token (required) |
| firstName | body | string | No | User's first name (required) |
| lastName | body | string | No | User's last name (required) |

**Response** `200`
```json
{ ok: true, user: { id, email, name, role } }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Invite not found, expired, or already used" }
```

---

### `GET` /api/v1/invite/verify

Verifies an invite token and returns invite details for the accept form. Does not consume the invite.

**Auth**: None

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| token | query | string | No | Invite token to verify (required) |

**Response** `200`
```json
{ ok: true, invite: { email, firstName, lastName, domainName?, expiresAt } }
```

**Response** `400`
```json
{ ok: false, error: "Token is required" }
```

**Response** `404`
```json
{ ok: false, error: "Invite not found, expired, or already used" }
```

---

## Layers

### `GET` /api/v1/layers/diff

Compute the inheritance diff between a base archetype and an overlay identity spec

**Auth**: Session · **Scope**: `layers:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| overlayId | query | string | No | UUID of the overlay (domain) spec |

**Response** `200`
```json
{ ok: true, diff: LayerDiffResult }
```

**Response** `400`
```json
{ ok: false, error: "overlayId required" }
```

**Response** `404`
```json
{ ok: false, error: "Spec not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/layers/specs

List all overlay identity specs grouped by their base archetype

**Auth**: Session · **Scope**: `layers:read`

**Response** `200`
```json
{ ok: true, bases: [...] }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Memories

### `GET` /api/v1/memories

List caller memories with filtering and pagination. By default excludes superseded and expired memories. Supports search across key, value, and evidence fields.

**Auth**: Session · **Scope**: `memories:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | query | string | No | Filter by caller ID (optional) |
| category | query | string | No | Filter by MemoryCategory (FACT | PREFERENCE | EVENT | TOPIC | RELATIONSHIP | CONTEXT) (optional) |
| search | query | string | No | Full-text search across key, value, evidence (optional) |
| includeSuperseded | query | string | No | Include superseded memories ("true" to include, default false) |
| limit | query | number | No | Max results to return (default 100, max 500) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok: true, memories: [...], total: number, limit: number, offset: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch memories" }
```

---

### `POST` /api/v1/memories

Create a new memory manually for a caller. Handles deduplication: if a memory with the same normalized key exists, it either supersedes the old value or updates confidence if the value matches.

**Auth**: Session · **Scope**: `memories:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | body | string | No | The caller this memory belongs to (required) |
| category | body | string | No | MemoryCategory enum value (required) |
| key | body | string | No | Memory key/label (required) |
| value | body | string | No | Memory value (required) |
| evidence | body | string | No | Supporting evidence text (optional) |
| context | body | string | No | Context in which the memory was captured (optional) |
| confidence | body | number | No | Confidence score 0-1 (default 0.95 for manual entries) |
| expiresInDays | body | number | No | Auto-expire after N days (optional, null = never) |

**Response** `200`
```json
{ ok: true, memory: {...}, supersededId: string|null }
```

**Response** `400`
```json
{ ok: false, error: "callerId is required" }
```

**Response** `404`
```json
{ ok: false, error: "Caller not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to create memory" }
```

---

## Other

### `GET` /api/v1/join/[token]

Verify a classroom join token. Returns classroom info if valid.

**Auth**: None

---

### `POST` /api/v1/join/[token]

Accept a classroom join link. Creates User + Caller + sets session.

**Auth**: None

---

## Parameters

### `GET` /api/v1/parameters

List parameters with React-Admin compatible pagination, sorting, and filtering. Includes tags, prompt slug links, and source feature set.

**Auth**: Session · **Scope**: `parameters:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sort | query | string | No | JSON array [field, order] e.g. ["parameterId", "ASC"] |
| range | query | string | No | JSON array [start, end] e.g. [0, 24] |
| filter | query | string | No | JSON object e.g. {"q": "search term", "isActive": true, "parameterType": "BEHAVIOR"} |

**Response** `200`
```json
Parameter[] (with Content-Range header for pagination)
```

**Response** `500`
```json
{ error: "..." }
```

---

### `POST` /api/v1/parameters

Create a new parameter (React-Admin compatible)

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| parameterId | body | string | No | Unique semantic parameter ID (e.g. "B5-O", "VARK-V") |
| name | body | string | No | Display name |
| domainGroup | body | string | No | Domain group |
| sectionId | body | string | No | Section ID |
| scaleType | body | string | No | Scale type |
| directionality | body | string | No | Directionality |
| computedBy | body | string | No | Computed by |
| definition | body | string | No | Parameter definition |
| interpretationLow | body | string | No | Low-score interpretation |
| interpretationHigh | body | string | No | High-score interpretation |

**Response** `201`
```json
Parameter
```

**Response** `500`
```json
{ error: "..." }
```

---

### `DELETE` /api/v1/parameters/:id

Delete a parameter permanently (React-Admin compatible)

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |

**Response** `200`
```json
Parameter (the deleted record)
```

**Response** `500`
```json
{ error: "..." }
```

---

### `GET` /api/v1/parameters/:id

Get a single parameter by UUID with tags and prompt slug links (React-Admin compatible)

**Auth**: Session · **Scope**: `parameters:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |

**Response** `200`
```json
Parameter
```

**Response** `404`
```json
{ error: "Parameter not found" }
```

**Response** `500`
```json
{ error: "..." }
```

---

### `PUT` /api/v1/parameters/:id

Update a parameter's fields (React-Admin compatible). parameterId is immutable.

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |
| name | body | string | No | Display name |
| domainGroup | body | string | No | Domain group |
| sectionId | body | string | No | Section ID |
| scaleType | body | string | No | Scale type |
| directionality | body | string | No | Directionality |
| computedBy | body | string | No | Computed by |
| definition | body | string | No | Parameter definition |
| interpretationLow | body | string | No | Low-score interpretation |
| interpretationHigh | body | string | No | High-score interpretation |

**Response** `200`
```json
Parameter
```

**Response** `500`
```json
{ error: "..." }
```

---

### `DELETE` /api/v1/parameters/:id/anchors

Delete scoring anchors by IDs

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID or parameterId |

**Response** `200`
```json
{ ok: true, deleted: number }
```

**Response** `400`
```json
{ ok: false, error: "ids array required" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/parameters/:id/anchors

Get all scoring anchors for a parameter, ordered by score and sort order

**Auth**: Session · **Scope**: `parameters:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID or parameterId |

**Response** `200`
```json
{ ok: true, parameter: { id, parameterId, name, scaleType, interpretationHigh, interpretationLow }, anchors: ScoringAnchor[], count: number }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/parameters/:id/anchors

Add a scoring anchor to a parameter

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID or parameterId |
| example | body | string | No | The transcript excerpt or synthetic example (required) |
| score | body | number | No | The calibrated score, typically 0-1 (required) |
| rationale | body | string | No | Why this score |
| isGold | body | boolean | No | Is this a canonical example (default: false) |
| source | body | string | No | Where this anchor came from |

**Response** `200`
```json
{ ok: true, anchor: ScoringAnchor }
```

**Response** `400`
```json
{ ok: false, error: "example and score are required" }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PUT` /api/v1/parameters/:id/anchors

Bulk update scoring anchors (reorder or batch edit)

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID or parameterId |
| anchors | body | Array | No | Array of anchor updates: [{id: string, example?, score?, rationale?, positiveSignals?, negativeSignals?, isGold?, sortOrder?}] |

**Response** `200`
```json
{ ok: true, updated: number }
```

**Response** `400`
```json
{ ok: false, error: "anchors array required" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/parameters/:id/prompts

Detach a dynamic prompt slug from this parameter

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |
| slugId | query | string | No | The prompt slug UUID to detach (required) |

**Response** `200`
```json
{ ok: true, deleted: true }
```

**Response** `400`
```json
{ ok: false, error: "slugId query param is required" }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `404`
```json
{ ok: false, error: "Link not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/parameters/:id/prompts

Get all dynamic prompt slugs linked to this parameter, plus available slugs that could be linked

**Auth**: Session · **Scope**: `parameters:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |

**Response** `200`
```json
{ ok: true, links: PromptSlugParameter[], availableSlugs: PromptSlug[] }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PATCH` /api/v1/parameters/:id/prompts

Update a prompt-parameter link's weight or mode

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |
| slugId | body | string | No | The prompt slug UUID to update (required) |
| weight | body | number | No | Updated link weight |
| mode | body | string | No | "ABSOLUTE" or "DELTA" |

**Response** `200`
```json
{ ok: true, link: PromptSlugParameter }
```

**Response** `400`
```json
{ ok: false, error: "slugId is required" }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `404`
```json
{ ok: false, error: "Link not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/parameters/:id/prompts

Attach a dynamic prompt slug to this parameter

**Auth**: Session · **Scope**: `parameters:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| id | path | string | Yes | Parameter UUID |
| slugId | body | string | No | The prompt slug UUID to attach (required) |
| weight | body | number | No | Link weight (default: 1.0) |
| mode | body | string | No | "ABSOLUTE" or "DELTA" (default: "ABSOLUTE") |

**Response** `200`
```json
{ ok: true, link: PromptSlugParameter }
```

**Response** `400`
```json
{ ok: false, error: "slugId is required" }
```

**Response** `400`
```json
{ ok: false, error: "This dynamic prompt is already attached..." }
```

**Response** `404`
```json
{ ok: false, error: "Parameter not found" }
```

**Response** `404`
```json
{ ok: false, error: "Dynamic prompt not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/parameters/display-config

Returns parameter display configuration for UI rendering. Dynamically groups canonical parameters (Big Five, VARK, Other) with labels, colors, and section metadata. No hardcoding.

**Auth**: Session · **Scope**: `parameters:read`

**Response** `200`
```json
{ ok: true, grouped: { "Big Five": [], "VARK": [], "Other": [] }, params: Record<string, ParamDisplayInfo>, totalParameters: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/parameters/export

Export all parameters as a downloadable CSV file with tags (pipe-delimited) and slug links (pipe-delimited slugSlug:weight:mode)

**Auth**: Session · **Scope**: `parameters:read`

**Response** `200`
```json
text/csv (Content-Disposition: attachment; filename="parameters-export-YYYY-MM-DD.csv")
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Pipeline

### `GET` /api/v1/pipeline/manifest

Get the pipeline blueprint/manifest defining all pipeline stages and operations

**Auth**: Session · **Scope**: `pipeline:read`

**Response** `200`
```json
{ ok: true, manifest: PipelineManifest }
```

---

### `GET` /api/v1/pipeline/runs

List pipeline runs derived from ComposedPrompt records. Each run includes

**Auth**: Session · **Scope**: `pipeline:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | query | string | No | Filter runs by caller ID |
| limit | query | number | No | Max results (default 20) |
| offset | query | number | No | Pagination offset (default 0) |

**Response** `200`
```json
{ ok: true, runs: PipelineRun[], total: number, limit: number, offset: number }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch pipeline runs" }
```

---

### `GET` /api/v1/pipeline/runs/:runId

Get full details for a single pipeline run including all steps

**Auth**: Session · **Scope**: `pipeline:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| runId | path | string | Yes | Pipeline run UUID |

**Response** `200`
```json
{ ok: true, run: PipelineRun }
```

**Response** `404`
```json
{ ok: false, error: "Pipeline run not found" }
```

**Response** `500`
```json
{ ok: false, error: "Failed to fetch pipeline run" }
```

---

### `GET` /api/v1/pipeline/stages

Returns pipeline stage configuration for visualization and documentation.

**Auth**: Session · **Scope**: `pipeline:read`

**Response** `200`
```json
{ ok: true, stages: PipelineStage[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Playbooks

### `GET` /api/v1/playbooks

List all playbooks with optional domain and status filters

**Auth**: Session · **Scope**: `playbooks:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| domainId | query | string | No | Filter playbooks by domain ID |
| status | query | string | No | Filter playbooks by status (DRAFT, PUBLISHED, ARCHIVED) |

**Response** `200`
```json
{ ok: true, playbooks: Playbook[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/playbooks

Create a new playbook in DRAFT status

**Auth**: Session · **Scope**: `playbooks:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| name | body | string | No | Playbook name (required) |
| description | body | string | No | Playbook description |
| domainId | body | string | No | Domain ID to associate (required) |

**Response** `200`
```json
{ ok: true, playbook: Playbook }
```

**Response** `400`
```json
{ ok: false, error: "name and domainId are required" }
```

**Response** `404`
```json
{ ok: false, error: "Domain not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/playbooks/:playbookId

Delete a draft playbook and its items. Published playbooks cannot be deleted.

**Auth**: Session · **Scope**: `playbooks:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID |

**Response** `200`
```json
{ ok: true, message: "Playbook deleted" }
```

**Response** `400`
```json
{ ok: false, error: "Cannot delete a published playbook. Archive it instead." }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/playbooks/:playbookId

Get playbook details with all items, domain, system specs, and parent version

**Auth**: Session · **Scope**: `playbooks:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID |

**Response** `200`
```json
{ ok: true, playbook: Playbook }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PATCH` /api/v1/playbooks/:playbookId

Update playbook metadata, items, system spec toggles, status, or config settings

**Auth**: Session · **Scope**: `playbooks:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID |
| name | body | string | No | Updated playbook name |
| description | body | string | No | Updated description |
| items | body | Array | No | Replacement items array (for DRAFT playbooks) |
| specs | body | Array | No | System spec toggles array |
| toggleSpec | body | object | No | Single spec toggle { specId, enabled } |
| agentId | body | string | No | Agent ID reference |
| sortOrder | body | number | No | Domain-level sort order |
| domainId | body | string | No | Reassign to another domain |
| status | body | string | No | Status transition (DRAFT, ARCHIVED) |
| configSettings | body | object | No | Config settings (memory, learning, AI, thresholds) |

**Response** `200`
```json
{ ok: true, playbook: Playbook }
```

**Response** `400`
```json
{ ok: false, error: "..." }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/playbooks/:playbookId/enrollments

List enrolled callers for a playbook (class roster).

**Auth**: Session · **Scope**: `playbooks:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | The playbook ID |
| status | query | string | No | Filter by enrollment status (ACTIVE, COMPLETED, PAUSED, DROPPED) |

**Response** `200`
```json
{ ok: true, enrollments: CallerPlaybook[] }
```

---

### `GET` /api/v1/playbooks/:playbookId/parameters

Returns all parameters used by specs in this playbook, organized by category

**Auth**: Session · **Scope**: `playbooks:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID |

**Response** `200`
```json
{ ok: true, playbook: { id, name, status }, categories: ParametersByCategory[], counts: { parameters, anchors, categories } }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/playbooks/:playbookId/publish

Validates and publishes a playbook. Runs validation checks (items exist,

**Auth**: Session · **Scope**: `playbooks:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID (must be DRAFT) |

**Response** `200`
```json
{ ok: true, playbook: Playbook, validationErrors: [...], validationPassed: true, stats: {...} }
```

**Response** `400`
```json
{ ok: false, error: "Playbook is already published" }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/playbooks/:playbookId/tree

Returns a hierarchical tree structure of the playbook including domain,

**Auth**: Session · **Scope**: `playbooks:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| playbookId | path | string | Yes | Playbook UUID |

**Response** `200`
```json
{ ok: true, tree: TreeNode, stats: { totalItems, specCount, templateCount, systemSpecCount, systemSpecEnabledCount, parameterCount, targetCount } }
```

**Response** `404`
```json
{ ok: false, error: "Playbook not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Prompts

### `GET` /api/v1/prompt/compose-from-specs

Quick spec-based prompt composition for a caller by ID or identity ID.

**Auth**: Session · **Scope**: `prompts:compose`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | query | string | No | Caller UUID |
| callerIdentityId | query | string | No | Caller identity UUID |
| domain | query | string | No | Filter specs by domain |
| outputType | query | string | No | Filter specs by output type (MEASURE, LEARN) |

**Response** `200`
```json
{ ok: true, prompt: string, promptCount: number, specCount: number, memoryCount: number }
```

**Response** `400`
```json
{ ok: false, error: "Must provide callerId or callerIdentityId" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/prompt/compose-from-specs

Spec-based prompt composition. Gathers all active AnalysisSpecs with

**Auth**: Session · **Scope**: `prompts:compose`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| callerId | body | string | No | Fetch caller's parameter values and memories |
| callerIdentityId | body | string | No | Fetch caller identity's latest values |
| includeMemories | body | boolean | No | Include caller memories in composition (default true) |
| domain | body | string | No | Filter specs by domain |
| outputType | body | string | No | Filter specs by output type (MEASURE, LEARN) |

**Response** `200`
```json
{ ok: true, prompt: string, prompts: [...], metadata: { totalSpecs, specsWithTemplates, promptsRendered, memoriesIncluded, composedAt, parameterValuesUsed } }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Specs

### `GET` /api/v1/specs

List analysis specs with optional filtering by spec role

**Auth**: Session · **Scope**: `specs:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| role | query | string | No | Filter by specRole (e.g. EXTRACT, SYNTHESISE, CONSTRAIN) |

**Response** `200`
```json
{ ok: true, specs: AnalysisSpec[], count: number }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `DELETE` /api/v1/specs/:specId

Delete a spec permanently

**Auth**: Session · **Scope**: `specs:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| specId | path | string | Yes | Spec UUID |

**Response** `200`
```json
{ ok: true }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/specs/:specId

Get a single spec by ID with triggers, actions, parameters, and prompt slug data

**Auth**: Session · **Scope**: `specs:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| specId | path | string | Yes | Spec UUID |

**Response** `200`
```json
{ ok: true, spec: AnalysisSpec }
```

**Response** `404`
```json
{ ok: false, error: "Spec not found" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `PATCH` /api/v1/specs/:specId

Update a spec's metadata (name, description, isActive, isDirty, priority, config, promptTemplate)

**Auth**: Session · **Scope**: `specs:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| specId | path | string | Yes | Spec UUID |
| name | body | string | No | Updated display name |
| description | body | string | No | Updated description |
| isActive | body | boolean | No | Enable or disable spec |
| isDirty | body | boolean | No | Mark spec as dirty |
| priority | body | number | No | Spec priority |
| config | body | object | No | Spec configuration |
| promptTemplate | body | string | No | Prompt template text |

**Response** `200`
```json
{ ok: true, spec: AnalysisSpec }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/specs/create

Create a new BDD spec from JSON body, write to docs-archive/bdd-specs/ file, and optionally auto-activate

**Auth**: Session · **Scope**: `specs:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| spec | body | SpecFormData | No | The spec form data (id, title, version, domain, specType, specRole, outputType, story, parameters, etc.) |
| autoActivate | body | boolean | No | Whether to activate after creation (default: true) |

**Response** `200`
```json
{ ok: true, specId: string, featureSetId: string, featureId: string, activated: boolean, fileWritten: string|null }
```

**Response** `400`
```json
{ ok: false, error: "ID is required" }
```

**Response** `409`
```json
{ ok: false, error: "A spec with ID ... already exists" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/specs/import

List all BDD feature sets stored in the database (used by import UI to show existing specs)

**Auth**: Session · **Scope**: `specs:read`

**Response** `200`
```json
{ ok: true, count: number, specs: BDDFeatureSet[] }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `POST` /api/v1/specs/import

Import BDD spec files (.spec.json) via multipart form upload, upsert into database, and optionally activate

**Auth**: Session · **Scope**: `specs:write`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| autoActivate | body | boolean | No | Whether to activate specs after import (default: true) |

**Response** `200`
```json
{ ok: true, created: number, updated: number, errors: number, total: number, results: ImportResult[] }
```

**Response** `400`
```json
{ ok: false, error: "Expected multipart/form-data" }
```

**Response** `400`
```json
{ ok: false, error: "No files uploaded" }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

### `GET` /api/v1/specs/tree

Returns a hierarchical tree structure of ALL specs grouped by Domain > Scope > OutputType, with full trigger/action/parameter nesting

**Auth**: Session · **Scope**: `specs:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| active | query | string | No | Filter by active status: "true", "false", or "all" (default "all") |

**Response** `200`
```json
{ ok: true, tree: TreeNode, stats: { total, byDomain, byScope, byOutputType } }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Subjects

### `GET` /api/v1/subjects/:subjectId/curriculum

Get the most recent curriculum for this subject.

**Auth**: VIEWER · **Scope**: `subjects:read`

**Response** `200`
```json
{ curriculum: Curriculum | null }
```

---

### `PATCH` /api/v1/subjects/:subjectId/curriculum

Update curriculum (user edits to modules, delivery config, etc.)

**Auth**: OPERATOR · **Scope**: `subjects:write`

---

### `POST` /api/v1/subjects/:subjectId/curriculum

Generate or save curriculum.

**Auth**: OPERATOR · **Scope**: `subjects:write`

**Response** `202`
```json
{ ok, taskId } (generate mode)
```

**Response** `200`
```json
{ ok, mode: "save", curriculum } (save mode)
```

---

### `GET` /api/v1/subjects/:subjectId/curriculum/preview?taskId=xxx

Get the generated curriculum preview from a completed generation task.

**Auth**: VIEWER · **Scope**: `subjects:read`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| taskId | query | string | No | The curriculum_generation task ID |

**Response** `200`
```json
{ ok, curriculum, taskStatus }
```

**Response** `404`
```json
{ error } if task not found or no preview available
```

---

### `POST` /api/v1/subjects/:subjectId/upload

Drag-drop endpoint: upload a document, auto-create ContentSource,

**Auth**: OPERATOR · **Scope**: `subjects:write`

**Response** `202`
```json
{ ok, source, classification, awaitingClassification }
```

---

## System

### `GET` /api/v1/health

Basic liveness check. Returns OK with timestamp. Used by infrastructure probes and load balancers.

**Auth**: None · **Scope**: `system:health`

**Response** `200`
```json
{ ok: true, ts: "ISO8601" }
```

---

### `GET` /api/v1/ready

Readiness probe that verifies database connectivity via a simple SELECT query.

**Auth**: None · **Scope**: `system:readiness`

**Response** `200`
```json
{ ok: true, db: "ok", ts: "ISO8601" }
```

**Response** `503`
```json
{ ok: false, db: "down", error: "..." }
```

---

### `GET` /api/v1/system/readiness

Returns comprehensive system readiness status for the analyze workflow. Checks prerequisites (specs, parameters, run configs), data sources (callers, calls, transcripts), and suggests next actions.

**Auth**: None · **Scope**: `system:readiness`

**Response** `200`
```json
{ ok: true, ready: boolean, checks: {...}, sources: {...}, suggestedActions: [...], stats: {...}, timestamp: "ISO8601" }
```

**Response** `500`
```json
{ ok: false, ready: false, error: "...", checks: { database: { ok: false, message: "..." } } }
```

---

## Transcripts

### `GET` /api/v1/transcripts

React-Admin compatible endpoint for listing transcript files from configured sources directory. Supports JSON and TXT formats, pagination via Content-Range header, sorting, and search filtering.

**Auth**: None · **Scope**: `transcripts:list`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| sort | query | string | No | JSON array [field, order] e.g. ["modifiedAt", "DESC"] |
| range | query | string | No | JSON array [start, end] e.g. [0, 24] |
| filter | query | string | No | JSON object e.g. {"q": "search term"} |

**Response** `200`
```json
[{ id, filename, relativePath, path, sizeBytes, sizeMB, modifiedAt, callCount, date, type, status, fileHash, fileExt }]
```

**Response** `400`
```json
{ error: "Path is not a directory: ..." }
```

**Response** `500`
```json
{ error: "..." }
```

---

### `POST` /api/v1/transcripts/import

Imports transcript files into the database. Supports three modes: JSON body with filePaths, JSON body with fromKbPath auto-discovery, or FormData file uploads. Includes preview mode for conflict detection and user-controlled conflict resolution.

**Auth**: None · **Scope**: `transcripts:import`

| Parameter | In | Type | Required | Description |
|-----------|-----|------|----------|-------------|
| fromKbPath | body | boolean | No | Auto-discover from HF_KB_PATH/sources/transcripts/raw (JSON mode) |
| domainSlug | body | string | No | Domain slug for created callers (default: "mabel") |
| duplicateHandling | body | string | No | "skip" | "overwrite" | "create_new" (default: "skip") |
| preview | body | boolean | No | If true, only detect conflicts without importing |
| conflictResolutions | body | object | No | Map of conflictKey to "merge" | "create_new" | "skip" |

**Response** `200`
```json
{ ok: true, created: number, merged: number, updated: number, skipped: number, callers: [...], filesProcessed: number, callsImported: number, errors: [...] }
```

**Response** `400`
```json
{ ok: false, error: "No files uploaded" | "No files specified..." }
```

**Response** `500`
```json
{ ok: false, error: "..." }
```

---

## Vapi

### `POST` /api/v1/vapi/assistant-request

VAPI calls this at call start to get a per-caller assistant config.

**Auth**: webhook-secret · **Scope**: `vapi:assistant`

---

### `POST` /api/v1/vapi/knowledge

VAPI Custom Knowledge Base endpoint. Called every conversation turn.

**Auth**: webhook-secret · **Scope**: `vapi:knowledge`

---

### `POST` /api/v1/vapi/tools

VAPI Custom Tools endpoint. Called when the voice AI decides

**Auth**: webhook-secret · **Scope**: `vapi:tools`

---

### `POST` /api/v1/vapi/webhook

Receives VAPI webhook events. Handles end-of-call-report to

**Auth**: webhook-secret · **Scope**: `vapi:webhook`

---

## Voice Integration

HF integrates with popular voice platforms to analyse live conversations
in real time.

### VAPI

HF ships with a first-class VAPI integration. Point your VAPI assistant's
server URL at your HF instance:

```
Server URL: https://api.hf.app/api/v1/webhooks/vapi
```

Configure the following in your VAPI dashboard:

| Setting | Value |
|---------|-------|
| Server URL | `https://api.hf.app/api/v1/webhooks/vapi` |
| Auth Header | `Authorization: Bearer hf_live_xxx` |
| Events | `call.completed`, `call.transcript` |

HF will automatically:

1. Receive the transcript when the call ends
2. Match or create the caller by phone number
3. Run the full analysis pipeline
4. Update the caller's personality profile and memories

### Twilio

For Twilio-based voice systems, use the generic webhook endpoint:

```bash
curl -X POST https://api.hf.app/api/v1/webhooks/ingest \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "source": "twilio",
    "callSid": "CA1234567890",
    "transcript": "...",
    "callerPhone": "+15551234567",
    "duration": 180
  }'
```

### Generic webhook

Any voice platform can push transcripts through the generic ingest endpoint:

```bash
curl -X POST https://api.hf.app/api/v1/webhooks/ingest \
  -H "Authorization: Bearer $HF_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "source": "custom",
    "externalCallId": "your-call-id",
    "transcript": "Full conversation transcript...",
    "callerExternalId": "your-user-id",
    "metadata": {
      "duration": 240,
      "language": "en"
    }
  }'
```

### Transcript format

HF accepts transcripts in several formats:

| Format | Content-Type | Description |
|--------|-------------|-------------|
| Plain text | `text/plain` | Raw transcript string |
| JSON (HF) | `application/json` | Structured with speaker labels |
| JSON (VAPI) | `application/json` | Native VAPI transcript format |

Structured format with speaker labels:

```json
{
  "turns": [
    { "speaker": "agent", "text": "Hello, how can I help?" },
    { "speaker": "caller", "text": "I'd like to learn about..." }
  ]
}
```

---

## Deployment

### Cloud (managed)

The managed HF instance is available at `https://api.hf.app`. No setup
required -- create an account, generate an API key, and start making calls.

### Self-hosted

HF can be deployed in your own infrastructure for full data sovereignty.

#### Requirements

| Component | Minimum | Recommended |
|-----------|---------|-------------|
| **Runtime** | Node.js 20+ | Node.js 22 LTS |
| **Database** | PostgreSQL 15 | PostgreSQL 16 |
| **Memory** | 2 GB RAM | 4 GB RAM |
| **Storage** | 10 GB | 50 GB (for transcript storage) |

#### Docker Compose

```yaml
version: "3.8"
services:
  hf:
    image: ghcr.io/hf-platform/hf:latest
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://hf_user:password@postgres:5432/hf
      HF_SUPERADMIN_TOKEN: your-secret-token
      OPENAI_API_KEY: sk-...
      NEXTAUTH_SECRET: your-nextauth-secret
      NEXTAUTH_URL: https://your-domain.com
    depends_on:
      - postgres

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: hf_user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hf
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

#### Environment variables

| Variable | Required | Description |
|----------|----------|-------------|
| `DATABASE_URL` | Yes | PostgreSQL connection string |
| `HF_SUPERADMIN_TOKEN` | Yes | Admin API token |
| `OPENAI_API_KEY` | Yes | OpenAI key for analysis pipeline |
| `NEXTAUTH_SECRET` | Yes | Session encryption secret |
| `NEXTAUTH_URL` | Yes | Public URL of the instance |
| `HF_KB_PATH` | No | Path to knowledge base files |
| `HF_LOG_LEVEL` | No | Logging level (default: `info`) |

#### Initial setup

```bash
# Run database migrations
docker exec hf npx prisma migrate deploy

# Seed the system with default specs and parameters
docker exec hf npm run db:seed

# Verify the instance is healthy
curl https://your-domain.com/api/health
```

---

## Versioning

### URL versioning

The public API uses URL-based versioning:

```
https://api.hf.app/api/v1/callers
https://api.hf.app/api/v1/calls
```

The current stable version is **v1**. All examples in this document use v1.

### Stability guarantees

Within a major version:

- Existing fields are never removed or renamed.
- New optional fields may be added to responses.
- New optional query parameters may be added.
- Error codes and their meanings remain stable.

### Deprecation policy

When a breaking change is necessary:

1. The new version is released alongside the old one (e.g., v1 and v2).
2. The old version enters a **12-month deprecation window**.
3. Deprecated endpoints return a `Deprecation` header with the sunset date.
4. Email notifications are sent at 6 months, 3 months, and 1 month before sunset.

```
Deprecation: Sun, 01 Feb 2027 00:00:00 GMT
Sunset: Sun, 01 Feb 2027 00:00:00 GMT
Link: <https://docs.hf.app/api/v2/migration>; rel="successor-version"
```

### Beta endpoints

Endpoints marked as **beta** may change without a version bump. They are
indicated with a `X-HF-Beta: true` response header. Do not rely on beta
endpoints for production workflows without acknowledging this risk.

---

## Security

### Transport

All API traffic must use **HTTPS** (TLS 1.2+). Plain HTTP requests are
rejected with a `301` redirect.

### API key best practices

| Practice | Details |
|----------|---------|
| **Never commit keys** | Use environment variables or a secrets manager |
| **Rotate regularly** | Rotate production keys every 90 days |
| **Least privilege** | Issue keys with only the scopes they need |
| **Separate environments** | Use `hf_test_` keys for development, `hf_live_` for production |
| **Monitor usage** | Review API key activity in the dashboard |

### PII handling

HF processes conversational data that may contain personally identifiable
information (PII). The platform provides several controls:

| Control | Description |
|---------|-------------|
| **Data retention** | Configure automatic deletion of transcripts after N days |
| **PII redaction** | Enable automatic redaction of phone numbers, emails, and names in stored transcripts |
| **Caller anonymisation** | Replace caller identifiers with opaque tokens |
| **Export & delete** | GDPR-compliant data export and right-to-erasure endpoints |

#### Requesting data deletion

```bash
# Delete all data for a specific caller
curl -X DELETE https://api.hf.app/api/v1/callers/<CALLER_ID> \
  -H "Authorization: Bearer $HF_API_KEY"
```

This permanently removes the caller profile, all associated calls,
memories, personality data, and analysis results.

### IP allowlisting

Enterprise plans support restricting API key usage to specific IP
addresses or CIDR ranges. Configure this in the Dashboard under
**Settings > API Keys > IP Restrictions**.

### Audit logging

All API requests are logged with:

- Timestamp, method, path
- API key ID (not the full key)
- Source IP address
- Response status code
- Request duration

Audit logs are retained for 90 days and available via the Dashboard
or the `/api/v1/admin/audit-logs` endpoint.
