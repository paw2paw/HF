generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =========================
// PARAMETER TYPES
// =========================

// Classifies how a parameter behaves and is computed
enum ParameterType {
  TRAIT      // Stable personality traits (Big 5, etc.) - change slowly over many calls
  STATE      // Per-call state (engagement, mood) - measured each call
  ADAPT      // Delta/change parameters - computed from comparing calls
  GOAL       // Goal progress parameters - computed from target vs current
  CONFIG     // System/admin settings - not measured from calls, set by admins
  EXTERNAL   // Populated from external sources (assessments, user input) - not measured
}

model Parameter {
  id                   String   @id @default(uuid())
  parameterId          String   @unique
  sectionId            String
  domainGroup          String
  name                 String
  definition           String?
  measurementMvp       String?
  measurementVoiceOnly String?
  interpretationHigh   String?
  interpretationLow    String?
  scaleType            String
  directionality       String
  computedBy           String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Parameter classification
  parameterType        ParameterType @default(TRAIT)

  // For ADAPT parameters: which base parameter this tracks deltas for
  // e.g., "engagement_delta" tracks deltas of "engagement"
  baseParameterId      String?
  baseParameter        Parameter? @relation("DeltaBase", fields: [baseParameterId], references: [parameterId])
  deltaParameters      Parameter[] @relation("DeltaBase")

  // For GOAL parameters: target value and window
  goalTarget           Float?       // Target value to achieve (e.g., 0.8 for rapport)
  goalWindow           Int?         // Number of calls to consider for progress (e.g., 5)

  // Enrichment fields - populated by KB search to deepen understanding
  enrichedHigh         String?  @db.Text  // Expanded definition of high scores from KB
  enrichedLow          String?  @db.Text  // Expanded definition of low scores from KB
  enrichedAt           DateTime?          // When enrichment was last run
  enrichmentChunkIds   String[]           // IDs of KB chunks used for enrichment

  mappings             ParameterMapping[]

  // Status such as Active or MVP is represented via tags, not boolean columns
  tags                 ParameterTag[]

  // Analysis relations (opposite sides)
  analysisProfileParameters AnalysisProfileParameter[]
  callScores                CallScore[]
  controlSetParameters      ControlSetParameter[]

  // Knowledge base relations
  knowledgeArtifacts     KnowledgeArtifact[]
  knowledgeLinks         ParameterKnowledgeLink[]

  // Analysis spec relations (for MEASURE actions)
  analysisActions        AnalysisAction[]

  // Scoring calibration anchors (examples that define what scores mean)
  scoringAnchors         ParameterScoringAnchor[]

  // Prompt slugs driven by this parameter (many-to-many)
  promptSlugLinks        PromptSlugParameter[]
}

model ParameterMapping {
  id          String   @id @default(uuid())
  parameterId String
  targetType  String
  targetKey   String
  weight      Float?
  notes       String?

  parameter   Parameter @relation(fields: [parameterId], references: [parameterId])

  createdAt   DateTime @default(now())
}

model Tag {
  id        String   @id
  name      String         @unique  // Human-readable name, used in UI filters
  slug      String?        @unique
  tone      String?        // optional: neutral/info/success/warning/danger/brand
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  parameters ParameterTag[]
}

model ParameterTag {
  id          String   @id
  parameterId String
  tagId       String
  createdAt   DateTime @default(now())

  parameter   Parameter @relation(fields: [parameterId], references: [parameterId], onDelete: Cascade, onUpdate: Cascade)
  tag         Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([parameterId, tagId])
  @@index([tagId])
  @@index([parameterId])
}

// =========================
// ANALYSIS PROFILES + RUNS
// =========================

model AnalysisProfile {
  id          String   @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  // Locking mechanism - profile locks when compiled set is used
  usageCount  Int      @default(0)   // Number of analysis runs using compiled sets from this profile
  isLocked    Boolean  @default(false)
  lockedAt    DateTime?
  lockedReason String?              // e.g., "Used by compiled set 'v1.0 Full Analysis'"

  parameters    AnalysisProfileParameter[]
  runs          AnalysisRun[]
  compiledSets  CompiledAnalysisSet[]

  @@map("ParameterSet") // Keep existing table name for backwards compatibility
}

model AnalysisProfileParameter {
  id                String   @id @default(uuid())
  analysisProfileId String   @map("parameterSetId")
  parameterId       String

  // Snapshot of parameter content at run-time
  definition         String?
  scaleType          String?
  directionality     String?
  interpretationLow  String?
  interpretationHigh String?

  // EQ-style configuration fields
  enabled            Boolean  @default(true)   // Whether this parameter is active in this profile
  weight             Float    @default(1.0)    // 0.0-2.0 multiplier for importance
  biasValue          Float?                    // Optional bias adjustment (-1.0 to +1.0)
  thresholdLow       Float?                    // Optional: custom low threshold
  thresholdHigh      Float?                    // Optional: custom high threshold

  createdAt DateTime @default(now())

  analysisProfile AnalysisProfile @relation(fields: [analysisProfileId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  parameter       Parameter       @relation(fields: [parameterId], references: [parameterId], onDelete: Restrict, onUpdate: Cascade)

  @@unique([analysisProfileId, parameterId])
  @@index([analysisProfileId])
  @@index([parameterId])
  @@map("ParameterSetParameter") // Keep existing table name
}

model AnalysisRun {
  id                String   @id @default(uuid())
  analysisProfileId String?  @map("parameterSetId")
  compiledSetId     String?  // Reference to compiled set used for this run

  // e.g. QUEUED | RUNNING | SUCCEEDED | FAILED
  status     String
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  metadata   Json?    // Additional run metadata

  createdAt DateTime @default(now())

  analysisProfile AnalysisProfile?     @relation(fields: [analysisProfileId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  compiledSet     CompiledAnalysisSet? @relation(fields: [compiledSetId], references: [id])
  scores          CallScore[]

  @@index([analysisProfileId])
  @@index([compiledSetId])
  @@index([status])
}

// =========================
// COMPILED ANALYSIS SETS
// =========================
// A compiled set is a validated, enriched snapshot of an AnalysisProfile
// ready for production use. Once used, it locks the source profile.

enum CompilationStatus {
  DRAFT       // Initial state, not yet compiled
  COMPILING   // Compilation in progress
  READY       // Validated and ready for use
  ERROR       // Compilation failed
  SUPERSEDED  // Replaced by a newer version
}

model CompiledAnalysisSet {
  id                String   @id @default(uuid())
  name              String
  description       String?
  version           String   @default("1.0")

  // Source profile (locked when this set is used)
  analysisProfileId String
  analysisProfile   AnalysisProfile @relation(fields: [analysisProfileId], references: [id])

  // Compilation status
  status            CompilationStatus @default(DRAFT)
  compiledAt        DateTime?
  compiledBy        String?           // User or system that compiled

  // Validation results
  validationErrors  Json?             // Array of { specId/parameterId, error, severity }
  validationPassed  Boolean @default(false)

  // What's included (spec IDs from the profile)
  specIds           String[]          // AnalysisSpec IDs included in compilation

  // Enrichment / RAG context
  ragContext        String?  @db.Text // Assembled KB context for prompts
  kbChunksUsed      String[]          // IDs of KB chunks used for enrichment

  // Computed stats at compile time
  measureSpecCount  Int      @default(0)
  learnSpecCount    Int      @default(0)
  parameterCount    Int      @default(0)
  anchorCount       Int      @default(0)

  // Version chain
  parentVersionId   String?
  parentVersion     CompiledAnalysisSet?  @relation("VersionChain", fields: [parentVersionId], references: [id])
  childVersions     CompiledAnalysisSet[] @relation("VersionChain")

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Runs using this compiled set
  runs              AnalysisRun[]

  @@index([analysisProfileId])
  @@index([status])
}

// =========================
// USERS
// =========================

model User {
  id        String   @id @default(uuid())
  email     String?
  name      String?
  phone     String?
  externalId String? @unique

  // Relations
  personality             UserPersonality?
  personalityObservations PersonalityObservation[]
  calls                   Call[]
  promptSlugSelections    PromptSlugSelection[]

  // Memory system
  memories                UserMemory[]
  memorySummary           UserMemorySummary?

  // Callers (phone numbers, etc.) linked to this user
  callers                 Caller[]

  createdAt   DateTime @default(now())

  @@index([externalId])
}

model Call {
  id         String   @id @default(uuid())
  source     String
  externalId String?
  transcript String
  createdAt  DateTime @default(now())

  // User and control set tracking
  userId        String?
  controlSetId  String?

  user          User?       @relation(fields: [userId], references: [id])
  controlSet    ControlSet? @relation(fields: [controlSetId], references: [id])

  // Call sequencing for delta calculations
  // Links to the previous call for this user (for computing ADAPT parameters)
  previousCallId String?
  previousCall   Call?    @relation("CallSequence", fields: [previousCallId], references: [id])
  nextCalls      Call[]   @relation("CallSequence")
  callSequence   Int?     // 1, 2, 3... for this user's calls

  scores                 CallScore[]
  rewardScore            RewardScore?
  personalityObservation PersonalityObservation?
  promptSlugSelections   PromptSlugSelection[]

  // Memory extraction
  extractedMemories      UserMemory[]

  @@index([source])
  @@index([externalId])
  @@index([userId])
  @@index([controlSetId])
  @@index([previousCallId])
}

model CallScore {
  id            String   @id @default(uuid())
  analysisRunId String
  callId        String
  parameterId   String

  score      Float?
  confidence Float?
  evidence   String?

  createdAt DateTime @default(now())

  run       AnalysisRun @relation(fields: [analysisRunId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  call      Call        @relation(fields: [callId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  parameter Parameter   @relation(fields: [parameterId], references: [parameterId], onDelete: Restrict, onUpdate: Cascade)

  @@unique([analysisRunId, callId, parameterId])
  @@index([analysisRunId])
  @@index([callId])
  @@index([parameterId])
}

// =========================
// KNOWLEDGE BASE (DOCS/KB)
// =========================

enum IngestionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

model KnowledgeDoc {
  id         String   @id @default(uuid())

  // Absolute or repo-relative path to the file that was ingested
  sourcePath String   @unique

  // Best-effort title (e.g. from YAML frontmatter or first H1)
  title      String?

  // Original full text (normalized)
  content    String   @db.Text

  // Optional metadata extracted from frontmatter or filename conventions
  meta       Json?

  // Content hash to detect changes and avoid unnecessary re-index
  contentSha String

  // Ingestion tracking (for resumable processing)
  status          IngestionStatus  @default(PENDING)
  ingestedAt      DateTime?
  chunksExpected  Int?             // Total chunks this doc should have
  chunksCreated   Int              @default(0)
  errorMessage    String?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  chunks     KnowledgeChunk[]

  @@index([updatedAt])
  @@index([contentSha])
  @@index([status])
}

model KnowledgeChunk {
  id         String   @id @default(uuid())
  docId      String

  // Monotonic index within the document
  chunkIndex Int

  // Character offsets in the parent document content
  startChar  Int
  endChar    Int

  // Chunk text that is used for retrieval
  content    String

  // Optional future fields
  tokens     Int?

  createdAt  DateTime @default(now())

  doc        KnowledgeDoc @relation(fields: [docId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  embedding  VectorEmbedding?
  parameterLinks ParameterKnowledgeLink[]

  @@unique([docId, chunkIndex])
  @@index([docId])
  @@index([chunkIndex])
}

// Vector embeddings for semantic search
model VectorEmbedding {
  id              String   @id @default(uuid())
  chunkId         String   @unique

  // Vector data (stored as bytes, converted to/from float[] in app)
  // In production, use pgvector extension: Unsupported("vector(1536)")
  embeddingData   Bytes    // Serialized float32 array

  // Embedding metadata
  model           String   // "text-embedding-3-small", "text-embedding-3-large"
  dimensions      Int      // 1536, 3072, etc.

  createdAt       DateTime @default(now())

  chunk           KnowledgeChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@index([chunkId])
  @@index([model])
}

// Knowledge artifacts curated for specific parameters
enum ArtifactType {
  SCORING_GUIDE      // "How to score openness from conversation"
  EXAMPLES           // "Examples of high/low openness in calls"
  RESEARCH_SUMMARY   // "Research findings on openness indicators"
  PROMPT_TEMPLATE    // "LLM prompt template for scoring openness"
  CALIBRATION_DATA   // "Benchmark examples with known scores"
}

model KnowledgeArtifact {
  id              String       @id @default(uuid())
  parameterId     String?      // Link to specific parameter

  // Artifact type and content
  type            ArtifactType
  title           String
  content         String       @db.Text  // Condensed, curated content

  // Source tracking
  sourceChunkIds  String[]     // Which chunks contributed to this artifact
  confidence      Float?       // How confident are we in this artifact?

  // Metadata
  tags            String[]     // ["openness", "high_indicators", "conversational"]
  version         String       @default("1.0")

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  parameter       Parameter?   @relation(fields: [parameterId], references: [id])

  @@index([parameterId])
  @@index([type])
}

// Junction table: Parameter ↔ Knowledge chunks (with relevance scores)
model ParameterKnowledgeLink {
  id              String   @id @default(uuid())
  parameterId     String
  chunkId         String
  relevanceScore  Float    // How relevant is this chunk? (from vector similarity)

  parameter       Parameter      @relation(fields: [parameterId], references: [id])
  chunk           KnowledgeChunk @relation(fields: [chunkId], references: [id])

  createdAt       DateTime @default(now())

  @@unique([parameterId, chunkId])
  @@index([parameterId])
  @@index([chunkId])
  @@index([relevanceScore])
}

// =========================
// TRANSCRIPT PROCESSING
// =========================

enum FileType {
  BATCH_EXPORT
  SINGLE_CALL
  CSV_EXPORT
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL      // Some calls extracted, some failed
  FAILED       // File-level failure (invalid JSON, unreadable, etc.)
}

enum FailedCallErrorType {
  NO_TRANSCRIPT     // No transcript field found in call
  INVALID_FORMAT    // Malformed call structure
  DUPLICATE         // Call already exists (by externalId)
  DB_ERROR          // Database write failure
  NO_CUSTOMER       // Could not identify caller
  UNKNOWN           // Other/unknown error
}

model ProcessedFile {
  id              String           @id @default(uuid())
  filename        String
  filepath        String
  fileHash        String           @unique
  fileType        FileType
  callCount       Int              // Total calls found in file
  callsExtracted  Int              @default(0)  // Successfully extracted
  callsFailed     Int              @default(0)  // Failed to extract
  usersCreated    Int              @default(0)  // Users created during processing
  sizeBytes       BigInt
  status          ProcessingStatus @default(PENDING)
  processedAt     DateTime?
  sourcePreserved Boolean          @default(true)
  errorMessage    String?

  failedCalls     FailedCall[]
  createdAt       DateTime          @default(now())

  @@unique([filepath, filename])
}

// Individual failed call extractions for review/retry
model FailedCall {
  id              String              @id @default(uuid())
  processedFileId String
  callIndex       Int                 // Position in source file (0-based)
  externalId      String?             // Call ID if available
  errorType       FailedCallErrorType
  errorMessage    String
  rawData         Json                // The original call object that failed
  retryCount      Int                 @default(0)
  resolvedAt      DateTime?           // When manually resolved/skipped

  processedFile   ProcessedFile       @relation(fields: [processedFileId], references: [id], onDelete: Cascade)
  createdAt       DateTime            @default(now())

  @@index([processedFileId])
  @@index([errorType])
  @@index([resolvedAt])
}

// =========================
// USER PERSONALITY & PROFILING
// =========================

// Personality observation from a single call (time series data)
model PersonalityObservation {
  id              String   @id @default(uuid())
  userId          String
  callId          String   @unique
  controlSetId    String?  // Which ControlSet was active during this call

  // Observed personality traits from this call (0-1 scale)
  // Scored against Parameters in knowledge bank
  openness        Float?
  conscientiousness Float?
  extraversion    Float?
  agreeableness   Float?
  neuroticism     Float?

  // Metadata
  observedAt      DateTime @default(now())
  confidence      Float?   // How confident is this observation?
  decayFactor     Float    @default(1.0)  // Used for time-based decay

  user            User     @relation(fields: [userId], references: [id])
  call            Call     @relation(fields: [callId], references: [id])
  controlSet      ControlSet? @relation(fields: [controlSetId], references: [id])

  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([callId])
  @@index([controlSetId])
  @@index([observedAt])
}

// Aggregated personality profile (computed from observations with decay)
model UserPersonality {
  id              String   @id @default(uuid())
  userId          String   @unique

  // Aggregated personality traits (0-1 scale)
  // Computed from PersonalityObservations with time decay
  openness        Float?
  conscientiousness Float?
  extraversion    Float?
  agreeableness   Float?
  neuroticism     Float?

  // Communication style preferences (derived from patterns)
  preferredTone   String?  // casual, formal, professional
  preferredLength String?  // brief, detailed, verbose
  technicalLevel  String?  // novice, intermediate, expert

  // Aggregation metadata
  lastAggregatedAt  DateTime?
  observationsUsed  Int      @default(0)
  confidenceScore   Float?   // 0-1: How confident are we in this profile?
  decayHalfLife     Int      @default(30) // Days until observation weight halves

  user            User     @relation(fields: [userId], references: [id])
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// =========================
// USER MEMORY SYSTEM
// =========================

// Memory categories for extracted facts
enum MemoryCategory {
  FACT           // Immutable facts: "lives in London", "works at Acme Corp"
  PREFERENCE     // User preferences: "prefers email over phone", "likes brief answers"
  EVENT          // Time-bound events: "asked about pricing on Jan 15", "complained about X"
  TOPIC          // Topics discussed: "interested in product X", "mentioned competitor Y"
  RELATIONSHIP   // Relationships: "has 2 kids", "reports to Sarah"
  CONTEXT        // Situational context: "traveling next week", "in a meeting"
}

// Memory source type
enum MemorySource {
  EXTRACTED      // Automatically extracted by analysis agent
  INFERRED       // Inferred from patterns across calls
  STATED         // Explicitly stated by user
  CORRECTED      // User or operator corrected a previous memory
}

// Individual memory entries extracted from calls
model UserMemory {
  id              String         @id @default(uuid())
  userId          String
  callId          String?        // Source call (null if inferred from multiple)

  // Memory classification
  category        MemoryCategory
  source          MemorySource   @default(EXTRACTED)

  // Key-value structure
  key             String         // e.g., "location", "job_title", "preference_contact_method"
  value           String         // e.g., "London", "Software Engineer", "email"
  normalizedKey   String?        // Canonical key for deduplication

  // Context and evidence
  evidence        String?        // The excerpt from transcript that supports this
  context         String?        // Additional context about the extraction

  // Confidence and decay
  confidence      Float          @default(0.8)  // 0-1: How confident in this memory?
  decayFactor     Float          @default(1.0)  // Current decay weight
  expiresAt       DateTime?      // Some memories expire (e.g., "traveling next week")

  // Version/contradiction handling
  supersededById  String?        // If corrected/updated, points to newer memory
  supersededBy    UserMemory?    @relation("MemorySupersession", fields: [supersededById], references: [id])
  supersedes      UserMemory[]   @relation("MemorySupersession")

  // Metadata
  extractedAt     DateTime       @default(now())
  extractedBy     String?        // Agent that extracted this (e.g., "memory_extractor_v1")
  verifiedAt      DateTime?      // When a human/system verified this
  verifiedBy      String?        // Who verified

  user            User           @relation(fields: [userId], references: [id])
  call            Call?          @relation(fields: [callId], references: [id])

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([userId])
  @@index([callId])
  @@index([category])
  @@index([key])
  @@index([normalizedKey])
  @@index([extractedAt])
  @@index([confidence])
}

// Aggregated memory summary per user (like a "profile card")
model UserMemorySummary {
  id              String   @id @default(uuid())
  userId          String   @unique

  // Aggregated memory counts by category
  factCount       Int      @default(0)
  preferenceCount Int      @default(0)
  eventCount      Int      @default(0)
  topicCount      Int      @default(0)

  // Key facts (denormalized for quick access)
  // These are the most confident, recent, relevant facts
  keyFacts        Json     @default("[]")  // Array of {key, value, confidence}

  // Common topics/interests
  topTopics       Json     @default("[]")  // Array of {topic, frequency, lastMentioned}

  // Preferences summary
  preferences     Json     @default("{}")  // {contactMethod: "email", responseLength: "brief", ...}

  // Last activity
  lastMemoryAt    DateTime?
  lastAggregatedAt DateTime?

  user            User     @relation(fields: [userId], references: [id])
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// =========================
// CONTROL SETS & PROMPT TEMPLATES
// =========================

model ControlSet {
  id          String   @id @default(uuid())
  name        String
  description String?
  version     String   // v1.0, v1.1, etc.
  isActive    Boolean  @default(false)

  // Link to prompt template
  promptTemplateId String?
  promptTemplate   PromptTemplate? @relation(fields: [promptTemplateId], references: [id])

  // Expected personality profile (target values for this control set)
  // These are the "ideal" personality traits this control set aims to work with
  expectedOpenness        Float?
  expectedConscientiousness Float?
  expectedExtraversion    Float?
  expectedAgreeableness   Float?
  expectedNeuroticism     Float?

  // Parameter values for this control set
  parameters  ControlSetParameter[]

  // Track which calls used this control set
  calls       Call[]

  // Track personality observations from calls using this control set
  personalityObservations PersonalityObservation[]

  // Performance metrics (calculated)
  avgScore    Float?
  callCount   Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
}

// Junction table: ControlSet ↔ Parameter values
model ControlSetParameter {
  id            String     @id @default(uuid())
  controlSetId  String
  parameterId   String
  value         String     // JSON value

  controlSet    ControlSet @relation(fields: [controlSetId], references: [id], onDelete: Cascade)
  parameter     Parameter  @relation(fields: [parameterId], references: [id])

  @@unique([controlSetId, parameterId])
  @@index([controlSetId])
  @@index([parameterId])
}

model PromptTemplate {
  id                    String   @id @default(uuid())
  name                  String
  version               String
  description           String?

  // Base system prompt with placeholders
  systemPrompt          String   @db.Text

  // JSON structure for personality modifiers
  // { openness: { high: "...", low: "..." }, ... }
  personalityModifiers  Json?

  // Template for injecting conversation context
  contextTemplate       String?  @db.Text

  isActive              Boolean  @default(false)

  controlSets           ControlSet[]
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([isActive])
}

// =========================
// REWARD MODEL SCORING
// =========================

model RewardScore {
  id              String   @id @default(uuid())
  callId          String   @unique

  // Overall reward score
  overallScore    Float

  // Dimension scores (weighted components)
  clarityScore    Float?
  empathyScore    Float?
  resolutionScore Float?
  efficiencyScore Float?
  coherenceScore  Float?

  // Scoring metadata
  modelVersion    String   // Which reward model version
  scoredAt        DateTime @default(now())
  scoredBy        String?  // Agent/human identifier

  // Extracted outcome signals
  customerSatisfaction Float?     // 0-1 scale
  taskCompleted        Boolean?
  escalated            Boolean?
  followUpRequired     Boolean?

  // Link scoring to parameters used
  parametersSnapshot   Json?      // Snapshot of parameter values at call time

  call            Call     @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@index([overallScore])
  @@index([scoredAt])
}

// =========================
// AGENT INSTANCES & RUNS
// =========================

enum AgentInstanceStatus {
  DRAFT
  PUBLISHED
  SUPERSEDED
  ARCHIVED
}

enum AgentRunStatus {
  QUEUED
  RUNNING
  OK
  ERROR
}

// Agent instance with draft/publish workflow
model AgentInstance {
  id              String              @id @default(uuid())

  // Reference to manifest agent (e.g., "knowledge_extractor")
  agentId         String

  // Human-readable overrides (can override manifest)
  name            String?
  description     String?

  // Version tracking
  version         String              @default("v1.0")

  // Status workflow
  status          AgentInstanceStatus @default(DRAFT)

  // Settings snapshot (JSON - merged manifest defaults + overrides)
  settings        Json                @default("{}")

  // Content hash for change detection
  settingsHash    String?

  // Version chain (for history)
  parentVersionId String?
  parentVersion   AgentInstance?      @relation("VersionChain", fields: [parentVersionId], references: [id])
  childVersions   AgentInstance[]     @relation("VersionChain")

  // Timestamps
  createdAt       DateTime            @default(now())
  publishedAt     DateTime?
  updatedAt       DateTime            @updatedAt

  // Track which runs used this instance
  runs            AgentRun[]

  @@unique([agentId, version])
  @@index([agentId])
  @@index([status])
  @@index([parentVersionId])
}

// Persistent agent run history
model AgentRun {
  id              String           @id @default(uuid())

  // Which agent instance was used (nullable for legacy/manifest-only runs)
  agentInstanceId String?
  agentInstance   AgentInstance?   @relation(fields: [agentInstanceId], references: [id])

  // Fallback: agentId if no instance
  agentId         String
  agentTitle      String?

  // Execution details
  opid            String?
  dryRun          Boolean          @default(false)

  // Status and timing
  status          AgentRunStatus
  startedAt       DateTime         @default(now())
  finishedAt      DateTime?

  // Output
  summary         String?
  stdout          String?          @db.Text
  stderr          String?          @db.Text

  // Artifacts as JSON array
  artifacts       Json             @default("[]")

  createdAt       DateTime         @default(now())

  @@index([agentInstanceId])
  @@index([agentId])
  @@index([status])
  @@index([startedAt])
}

// =========================
// PROMPT SLUG SELECTION
// =========================

model PromptSlugSelection {
  id        String   @id @default(uuid())
  callId    String
  userId    String?

  // Selected prompt slug
  promptSlug    String
  confidence    Float         // 0-1 confidence in selection
  reasoning     String?       // Why this slug was selected

  // Personality snapshot at selection time
  personalitySnapshot Json?   // Big 5 scores used for selection

  // Recent slugs context (to avoid repetition)
  recentSlugs Json?           // Array of recently used slugs

  // Selection metadata
  selectedAt    DateTime @default(now())
  selectionMethod String @default("rule-based") // rule-based, ml-model, etc.

  // Relations
  call          Call     @relation(fields: [callId], references: [id], onDelete: Cascade)
  user          User?    @relation(fields: [userId], references: [id])

  // Link to reward (populated after call ends)
  reward          PromptSlugReward?

  @@index([callId])
  @@index([userId])
  @@index([promptSlug])
  @@index([selectedAt])
}

// Reward for a specific prompt slug selection
model PromptSlugReward {
  id              String   @id @default(uuid())
  selectionId     String   @unique

  // Computed reward score (-1.0 to +1.0)
  rewardScore     Float

  // Component scores that fed into reward
  components      Json     // { csat, duration, resolved, sentiment_delta, ... }

  // Source of reward signals
  explicitFeedback Json?   // Agent/customer ratings
  implicitSignals  Json?   // Call metrics
  derivedMetrics   Json?   // AI-computed metrics

  createdAt       DateTime @default(now())

  selection       PromptSlugSelection @relation(fields: [selectionId], references: [id], onDelete: Cascade)

  @@index([selectionId])
  @@index([rewardScore])
  @@index([createdAt])
}

// =========================
// ANALYSIS SPECIFICATIONS
// =========================
// Unified system for defining what to analyze in calls:
// - MEASURE: Score behaviors against parameter anchors → CallScore
// - LEARN: Learn structured facts about the caller → UserMemory

enum AnalysisOutputType {
  MEASURE    // Score against parameter anchors, produces CallScore
  LEARN      // Learn structured data about caller, produces UserMemory
  ADAPT      // Compute deltas and goal progress, produces CallScore for ADAPT parameters
}

// Top-level spec: defines a category of analysis
// e.g., "Personality - Openness", "Memory - Personal Facts"
model AnalysisSpec {
  id          String   @id @default(uuid())
  slug        String   @unique  // e.g., "personality-openness", "memory-personal-facts"
  name        String            // Human-readable title
  description String?  @db.Text // Full description with context

  // What this spec produces
  outputType  AnalysisOutputType @default(MEASURE)

  // Domain grouping (personality, memory, engagement, etc.)
  domain      String?           // e.g., "personality", "memory", "engagement"
  priority    Int      @default(0)  // Higher = more important
  isActive    Boolean  @default(true)

  // Versioning
  version     String   @default("1.0")

  // Compilation status tracking
  compiledAt        DateTime?          // When this spec was last compiled
  compiledSetId     String?            // Which compiled set includes this spec
  isDirty           Boolean  @default(true)  // True if spec changed since last compile
  dirtyReason       String?            // What changed: "trigger_added", "action_modified", etc.

  // Locking (when used by callers)
  isLocked          Boolean  @default(false)
  lockedAt          DateTime?
  lockedReason      String?            // e.g., "Used by 5 callers"
  usageCount        Int      @default(0)  // Number of callers using this spec

  // === PROMPT TEMPLATE ===
  // Template text with Mustache-style variables that gets rendered at prompt composition time
  // Variables: {{value}}, {{label}}, {{param.name}}, {{memories.facts}}, {{user.name}}
  // Conditionals: {{#if high}}...{{/if}}, {{#if low}}...{{/if}}
  promptTemplate    String?  @db.Text

  // Optional: link to existing PromptSlug for backwards compatibility
  promptSlugId      String?
  promptSlug        PromptSlug? @relation(fields: [promptSlugId], references: [id])

  triggers    AnalysisTrigger[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([domain])
  @@index([outputType])
  @@index([isActive])
  @@index([compiledSetId])
  @@index([isLocked])

  // Keep old name as map for migration compatibility
  @@map("BddFeature")
}

// Trigger: when to apply this analysis (Given/When/Then structure)
// e.g., "Caller returns after 2+ week break", "Caller mentions personal info"
model AnalysisTrigger {
  id          String   @id @default(uuid())
  specId      String   @map("featureId")

  // Gherkin-style structure
  given       String   @db.Text  // Context/precondition
  when        String   @db.Text  // Trigger/action
  then        String   @db.Text  // Expected outcome (summary)

  // Optional trigger metadata
  name        String?            // Short name for UI
  notes       String?  @db.Text  // Implementation notes

  // Ordering within spec
  sortOrder   Int      @default(0)

  spec        AnalysisSpec @relation(fields: [specId], references: [id], onDelete: Cascade)
  actions     AnalysisAction[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([specId])

  @@map("BddScenario")
}

// Action: what to do when trigger matches
// For MEASURE: score against a Parameter
// For LEARN: learn facts and store in a MemoryCategory
model AnalysisAction {
  id          String   @id @default(uuid())
  triggerId   String   @map("scenarioId")

  // What to look for / extract
  description String   @db.Text

  // Weight for aggregation (MEASURE only)
  weight      Float    @default(1.0)

  // === MEASURE fields ===
  // Link to Parameter for scoring (optional - only for MEASURE)
  parameterId String?
  parameter   Parameter? @relation(fields: [parameterId], references: [parameterId])

  // === LEARN fields ===
  // What type of memory to create (optional - only for LEARN)
  learnCategory    MemoryCategory?  @map("extractCategory")  // FACT, PREFERENCE, EVENT, RELATIONSHIP, etc.
  learnKeyPrefix   String?          @map("extractKeyPrefix") // Key prefix: "location", "person_", "prefers_"
  learnKeyHint     String?          @map("extractKeyHint")   // Hint for key generation: "Learn the specific location name"

  // Ordering within trigger
  sortOrder   Int      @default(0)

  trigger     AnalysisTrigger @relation(fields: [triggerId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([triggerId])
  @@index([parameterId])

  @@map("BddAcceptanceCriteria")
}

// =========================
// PARAMETER SCORING ANCHORS
// =========================

// Scoring Anchor: a concrete example that defines what a score means for a Parameter
// This is the CALIBRATION DATA - the AI sees these before scoring
// e.g., score=0.9 "Welcome back! I remember we were discussing X last time..."
// e.g., score=0.3 "Hi, how can I help you?"
model ParameterScoringAnchor {
  id          String   @id @default(uuid())
  parameterId String

  // The example
  example     String   @db.Text  // Transcript excerpt or synthetic example

  // The score this example represents
  score       Float              // The calibrated score for this example

  // Why this score? (helps AI understand the rubric)
  rationale   String?  @db.Text  // "This scores 0.9 because it demonstrates warmth AND memory"

  // Signal markers (what to look for)
  positiveSignals String[]       // ["references_previous", "warm_greeting", "uses_name"]
  negativeSignals String[]       // ["generic_greeting", "no_memory_reference"]

  // Is this a canonical/gold-standard example?
  isGold      Boolean  @default(false)

  // Source tracking
  source      String?            // "synthetic", "real_call:abc123", "expert_created"

  // Ordering (show lower scores first for calibration)
  sortOrder   Int      @default(0)

  parameter   Parameter @relation(fields: [parameterId], references: [parameterId], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([parameterId])
  @@index([score])
  @@index([isGold])
}

// Aggregated effectiveness stats per prompt slug + personality bucket
model PromptSlugStats {
  id                    String   @id @default(uuid())

  // The slug being tracked
  promptSlug            String

  // Personality bucket (e.g., "high_N", "high_E_low_N", "balanced")
  personalityBucket     String

  // Aggregated metrics
  totalUses             Int      @default(0)
  avgReward             Float    @default(0)
  successRate           Float    @default(0)  // % of positive rewards
  confidenceAdjustment  Float    @default(0)  // Learned adjustment to base confidence

  // Time-windowed stats (last 30 days)
  recentUses            Int      @default(0)
  recentAvgReward       Float    @default(0)

  // Last updated
  updatedAt             DateTime @updatedAt

  @@unique([promptSlug, personalityBucket])
  @@index([promptSlug])
  @@index([personalityBucket])
  @@index([avgReward])
}

// =========================
// PROMPT SLUG SYSTEM
// =========================
// Dynamic prompt composition based on parameter values, memories, and stacks
// Key concepts:
// - PromptBlock: Static prompt blocks (system prompts, safety, personas)
// - PromptSlug: Dynamic prompt fragments driven by parameter values
// - PromptStack: Ordered collection of blocks + slugs that compose into final prompt
// - "Last wins" override: Later items in stack override earlier guidance

enum PromptSlugSource {
  PARAMETER   // Driven by a parameter value (e.g., openness score)
  MEMORY      // Driven by user memory (e.g., preferences)
  COMPOSITE   // Combines multiple sources
  ADAPT       // Driven by ADAPT parameters (deltas, goals)
}

enum PromptSlugMode {
  ABSOLUTE    // Uses current value (e.g., openness = 0.8)
  DELTA       // Uses change from previous call (e.g., openness increased by 0.2)
  GOAL        // Uses goal progress (current / target)
}

enum PromptStackStatus {
  DRAFT       // Work in progress
  PUBLISHED   // Active and can be used by callers
  ARCHIVED    // Superseded by newer version
}

enum PromptStackItemType {
  BLOCK       // Static prompt block
  SLUG        // Dynamic slug driven by parameter/memory
  CALLER      // Auto-generated from caller's memories
  AUTO_SLUGS  // Auto-collect all relevant dynamic prompts for caller's parameters
}

// Static prompt blocks (system prompts, safety, personas)
// These are templates that don't change based on caller state
model PromptBlock {
  id          String   @id @default(uuid())
  slug        String   @unique  // e.g., "system-base", "safety-guardrails", "persona-friendly"
  name        String
  description String?

  // Block categorization
  category    String   // "system" | "safety" | "persona" | "instruction" | "custom"

  // The actual prompt content
  content     String   @db.Text

  // Status
  isActive    Boolean  @default(true)
  version     String   @default("1.0")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relation to stack items
  stackItems  PromptStackItem[]

  @@index([category])
  @@index([isActive])
}

// Dynamic prompt slug driven by parameter values
// Maps parameter value ranges to specific prompt text
model PromptSlug {
  id              String   @id @default(uuid())
  slug            String   @unique  // e.g., "openness-style", "memory-short-term"
  name            String
  description     String?

  // What drives this slug
  sourceType      PromptSlugSource

  // === PARAMETER source (many-to-many) ===
  // Parameters that drive this slug (can be multiple for COMPOSITE)
  parameters      PromptSlugParameter[]

  // === MEMORY source ===
  memoryCategory  String?   // Which memory category to pull from (FACT, PREFERENCE, EVENT, TOPIC, RELATIONSHIP)
  memoryMode      String?   // "latest" | "summary" | "all" | "count:N"

  // === MEMORY injection policy ===
  // Controls how much memory to inject and when
  memoryMaxItems      Int?      // Max memories to include (null = use global default)
  memoryMinConfidence Float?    // Minimum confidence threshold (null = use global default 0.5)
  memoryKeyPattern    String?   // Filter memories by key pattern (glob-style, e.g., "spouse_*")
  memoryDecayEnabled  Boolean   @default(true)  // Apply time-based decay weighting
  memorySummaryTemplate String? @db.Text  // If set, summarize memories using this template
  memoryTrigger       String?   // When to inject: "always" | "if_exists" | "on_topic" | "recent_only"

  // Value ranges that map to prompt text
  ranges          PromptSlugRange[]

  // Fallback if no range matches
  fallbackPrompt  String?  @db.Text

  // Priority for conflict resolution (higher = more important)
  priority        Int      @default(0)

  // Status
  isActive        Boolean  @default(true)
  version         String   @default("1.0")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relation to stack items
  stackItems      PromptStackItem[]

  // Relation to AnalysisSpecs that use this slug
  analysisSpecs   AnalysisSpec[]

  @@index([sourceType])
  @@index([isActive])
}

// Junction table: PromptSlug ↔ Parameter (many-to-many)
// Allows a single slug to be driven by multiple parameters
model PromptSlugParameter {
  id              String   @id @default(uuid())
  slugId          String
  parameterId     String

  // How this parameter influences the slug
  weight          Float    @default(1.0)  // Weight for composite evaluation
  mode            PromptSlugMode @default(ABSOLUTE)  // ABSOLUTE or DELTA

  // Ordering (for evaluation priority)
  sortOrder       Int      @default(0)

  slug            PromptSlug @relation(fields: [slugId], references: [id], onDelete: Cascade)
  parameter       Parameter  @relation(fields: [parameterId], references: [parameterId])

  createdAt       DateTime @default(now())

  @@unique([slugId, parameterId])
  @@index([slugId])
  @@index([parameterId])
}

// Range definition for a prompt slug
// Maps value ranges to specific prompt output
model PromptSlugRange {
  id          String   @id @default(uuid())
  slugId      String

  // Value range (for numeric parameters)
  minValue    Float?   // >= this value (null = no lower bound)
  maxValue    Float?   // < this value (null = no upper bound)

  // For memory-based slugs, condition string
  condition   String?  // e.g., "has_value", "contains:X", "recent"

  // The prompt text for this range
  prompt      String   @db.Text

  // Human-readable label for this range
  label       String?  // e.g., "High openness", "Low engagement"

  // Optional metadata
  metadata    Json?

  // Ordering (for display)
  sortOrder   Int      @default(0)

  slug        PromptSlug @relation(fields: [slugId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slugId])
  @@index([sortOrder])
}

// =========================
// PROMPT COMPOSITION CONFIG
// =========================

// Global configuration for prompt composition
// System-wide defaults that can be overridden per-slug
model PromptCompositionConfig {
  id                    String   @id @default(uuid())
  name                  String   @unique  // e.g., "default", "high-memory", "minimal"
  description           String?

  // Memory injection defaults
  memoryMaxCount        Int      @default(20)      // Max memories to inject globally
  memoryMinConfidence   Float    @default(0.5)     // Minimum confidence threshold
  memoryDecayEnabled    Boolean  @default(true)    // Apply time-based decay weighting
  memoryCategories      String[] // Categories to include (empty = all)

  // Summarization settings
  memorySummarizeAbove  Int?     // If > N memories, summarize instead of listing
  memorySummaryPrompt   String?  @db.Text  // Template for summarization

  // Context-awareness settings
  memoryRelevanceMode   String   @default("all")  // "all" | "topic-match" | "recent" | "weighted"
  memoryRecencyDays     Int?     // For "recent" mode: only include memories from last N days

  // Prompt assembly settings
  slugSeparator         String   @default("\n\n")  // How to join multiple slug outputs
  includeMetadata       Boolean  @default(false)   // Include debug metadata in output

  // Status
  isActive              Boolean  @default(true)
  isDefault             Boolean  @default(false)   // Use this config when none specified

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([isActive])
  @@index([isDefault])
}

// Prompt stack: ordered collection of blocks + slugs
// Composed at runtime to produce the final prompt
model PromptStack {
  id          String   @id @default(uuid())
  name        String
  description String?

  // Status workflow
  status      PromptStackStatus @default(DRAFT)

  // Is this the default stack for new callers?
  isDefault   Boolean  @default(false)

  // Version chain
  version           String   @default("1.0")
  parentVersionId   String?
  parentVersion     PromptStack?  @relation("StackVersionChain", fields: [parentVersionId], references: [id])
  childVersions     PromptStack[] @relation("StackVersionChain")

  // Usage tracking
  usageCount  Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  publishedAt DateTime?

  // Items in this stack (ordered)
  items       PromptStackItem[]

  // Callers using this stack
  callers     Caller[]

  @@index([status])
  @@index([isDefault])
}

// Item in a prompt stack (block, slug, or caller content)
model PromptStackItem {
  id              String   @id @default(uuid())
  stackId         String

  // What type of item
  itemType        PromptStackItemType

  // === BLOCK item ===
  blockId         String?
  block           PromptBlock? @relation(fields: [blockId], references: [id])

  // === SLUG item ===
  slugId          String?
  slug            PromptSlug? @relation(fields: [slugId], references: [id])

  // === CALLER item ===
  // Auto-generates content from caller's memories
  // Configure which memory categories to include
  callerMemoryCategories String[]  // e.g., ["FACT", "PREFERENCE"]
  callerMemoryLimit      Int?      // Max memories to include

  // === AUTO_SLUGS item ===
  // Auto-collect all relevant dynamic prompts based on caller's parameter values
  autoSlugSourceTypes    String[]  // e.g., ["PARAMETER", "COMPOSITE"] - which source types to include
  autoSlugOrderBy        String?   // "priority" | "domainGroup" | "name" - how to order collected prompts
  autoSlugLimit          Int?      // Max slugs to include (null = unlimited)
  autoSlugDomainFilter   String[]  // Optional: only include slugs from these domains

  // Item state
  isEnabled       Boolean  @default(true)

  // Ordering (critical for "last wins" override)
  sortOrder       Int      @default(0)

  stack           PromptStack @relation(fields: [stackId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([stackId])
  @@index([blockId])
  @@index([slugId])
  @@index([sortOrder])
}

// =========================
// CALLER MODEL
// =========================
// Represents an individual caller with their prompt state

model Caller {
  id              String   @id @default(uuid())

  // User reference (if identified)
  userId          String?
  user            User?    @relation(fields: [userId], references: [id])

  // External identifier (phone number, account ID, etc.)
  externalId      String?  @unique

  // Display name
  name            String?

  // === PROMPT STATE ===
  // Which stack is assigned to this caller
  promptStackId   String?
  promptStack     PromptStack? @relation(fields: [promptStackId], references: [id])

  // The composed prompt ready for the next call
  // This is the output of evaluating the stack against current state
  callerPrompt    String?  @db.Text

  // When was the prompt last composed
  promptComposedAt DateTime?

  // Snapshot of inputs used for last composition (for debugging/audit)
  promptSnapshot  Json?    // { parameterValues: {...}, memories: [...], stackVersion: "..." }

  // === STATS ===
  callCount       Int      @default(0)
  lastCallAt      DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([externalId])
  @@index([promptStackId])
}