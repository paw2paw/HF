generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =========================
// PARAMETER TYPES
// =========================

// Classifies how a parameter behaves and is computed
enum ParameterType {
  TRAIT // Stable personality traits (Big 5, etc.) - change slowly over many calls
  STATE // Per-call state (engagement, mood) - measured each call
  ADAPT // Delta/change parameters - computed from comparing calls
  GOAL // Goal progress parameters - computed from target vs current
  CONFIG // System/admin settings - not measured from calls, set by admins
  EXTERNAL // Populated from external sources (assessments, user input) - not measured
  BEHAVIOR // Agent behavior targets - how the agent should communicate (role_switch, empathy_rate, etc.)
}

// Content trust levels - classifies source authority for teaching materials
// L5=REGULATORY_STANDARD → L0=UNVERIFIED (see CONTENT_TRUST_V1 contract)
enum ContentTrustLevel {
  REGULATORY_STANDARD // L5: Exam board syllabus, regulatory handbook (e.g., CII R04 syllabus, FCA COBS)
  ACCREDITED_MATERIAL // L4: Approved study text (e.g., BFT/ActEd texts accredited by CII)
  PUBLISHED_REFERENCE // L3: Academic textbook, peer-reviewed journal
  EXPERT_CURATED      // L2: Content by qualified professional/instructor
  AI_ASSISTED         // L1: AI-generated, human-reviewed
  UNVERIFIED          // L0: Unreviewed submissions, user notes (default)
}

// Document classification - intrinsic type of a content source document
// Determines extraction strategy, categories, and pyramid structure
enum DocumentType {
  CURRICULUM  // Formal syllabus with LOs/ACs — auto-structures pyramid
  TEXTBOOK    // Dense reference material — full extraction + structuring
  WORKSHEET   // Learner activity sheet — structure/questions extraction
  EXAMPLE     // Illustrative document — light concept extraction
  ASSESSMENT  // Test/quiz material — questions/answers/misconceptions
  REFERENCE   // Glossary/cheat sheet — flat term extraction
}

// Conversation artifact types - content worth sharing from a call
enum ConversationArtifactType {
  SUMMARY // Call summary / key takeaways
  KEY_FACT // Important fact discussed or taught
  FORMULA // Mathematical or domain formula
  EXERCISE // Practice question or exercise
  RESOURCE_LINK // Book, tool, or resource reference
  STUDY_NOTE // Study note or revision aid
  REMINDER // Follow-up action or reminder
  MEDIA // Image, PDF, or audio clip
}

// Artifact trust level - how well the content traces to trusted sources
enum ArtifactTrustLevel {
  VERIFIED // All facts trace to ContentAssertions
  INFERRED // AI-generated but plausible
  UNVERIFIED // Caller-contributed or unverifiable
}

// Artifact delivery status
enum ArtifactStatus {
  PENDING // Extracted, not yet delivered
  SENT // Sent to channel (awaiting confirmation)
  DELIVERED // Confirmed delivered
  READ // Confirmed read/opened
  FAILED // Delivery failed
}

// Inbound message types from callers
enum InboundMessageType {
  TEXT
  IMAGE
  AUDIO
  DOCUMENT
}

// Goal types - different kinds of objectives for callers
enum GoalType {
  LEARN // Knowledge/skill acquisition (curriculum-based)
  ACHIEVE // Specific milestones or outcomes
  CHANGE // Behavior change, habit formation
  CONNECT // Relationship building, companionship
  SUPPORT // Emotional support, wellbeing
  CREATE // Creative projects, build something
}

// Call action types - actionable items that emerge from calls
enum CallActionType {
  SEND_MEDIA // Send doc/image/media to caller
  HOMEWORK   // Practice/study assignment for the caller
  TASK       // Generic actionable task
  FOLLOWUP   // Follow up on something discussed
  REMINDER   // Remember to do/check something
}

// Who needs to act on a call action
enum CallActionAssignee {
  CALLER   // Learner needs to do this
  OPERATOR // Admin/operator needs to fulfill
  AGENT    // AI agent should do this next call
}

// Call action completion lifecycle
enum CallActionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Call action priority
enum CallActionPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// How the action was created
enum CallActionSource {
  EXTRACTED // AI extracted from call transcript
  MANUAL    // Operator/admin created
}

// Goal lifecycle status
enum GoalStatus {
  ACTIVE // Currently being pursued
  COMPLETED // Successfully achieved
  PAUSED // Temporarily suspended
  ARCHIVED // No longer relevant
}

// CallerPlaybook enrollment status — tracks a caller's relationship to a specific playbook
enum CallerPlaybookStatus {
  ACTIVE // Currently enrolled, specs run in pipeline
  COMPLETED // Finished the course/playbook
  PAUSED // Temporarily suspended
  DROPPED // Explicitly withdrawn
}

// Caller role - what function this person serves in the learning platform
enum CallerRole {
  LEARNER // Default — uses the system as a student/participant
  TEACHER // Owns cohort groups, sees pupil dashboards
  TUTOR // 1-1 tutor, owns small groups or individual supervision
  PARENT // Parent/guardian access to child's progress
  MENTOR // Mentor with oversight of mentees
}

model Parameter {
  id                   String   @id @default(uuid())
  parameterId          String   @unique
  sectionId            String
  domainGroup          String
  name                 String
  definition           String?
  measurementMvp       String?
  measurementVoiceOnly String?
  interpretationHigh   String?
  interpretationLow    String?
  scaleType            String
  directionality       String
  computedBy           String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Parameter classification
  parameterType ParameterType @default(TRAIT)

  // Whether this parameter has adjustable targets (vs observational only)
  // True for BEHAVIOR parameters, false for TRAIT/STATE (observational)
  // When true, BehaviorTargets can be set at SYSTEM/PLAYBOOK/SEGMENT/CALLER levels
  isAdjustable Boolean @default(false)

  // For ADAPT parameters: which base parameter this tracks deltas for
  // e.g., "engagement_delta" tracks deltas of "engagement"
  baseParameterId String?
  baseParameter   Parameter?  @relation("DeltaBase", fields: [baseParameterId], references: [parameterId])
  deltaParameters Parameter[] @relation("DeltaBase")

  // For GOAL parameters: target value and window
  goalTarget Float? // Target value to achieve (e.g., 0.8 for rapport)
  goalWindow Int? // Number of calls to consider for progress (e.g., 5)

  // Enrichment fields - populated by KB search to deepen understanding
  enrichedHigh       String?   @db.Text // Expanded definition of high scores from KB
  enrichedLow        String?   @db.Text // Expanded definition of low scores from KB
  enrichedAt         DateTime? // When enrichment was last run
  enrichmentChunkIds String[] // IDs of KB chunks used for enrichment

  mappings ParameterMapping[]

  // Status such as Active or MVP is represented via tags, not boolean columns
  tags ParameterTag[]

  // Analysis relations (opposite sides)
  analysisProfileParameters AnalysisProfileParameter[]
  callScores                CallScore[]

  // Knowledge base relations
  knowledgeArtifacts KnowledgeArtifact[]
  knowledgeLinks     ParameterKnowledgeLink[]

  // Analysis spec relations (for MEASURE actions)
  analysisActions AnalysisAction[]

  // Scoring calibration anchors (examples that define what scores mean)
  scoringAnchors ParameterScoringAnchor[]

  // Prompt slugs driven by this parameter (many-to-many)
  promptSlugLinks PromptSlugParameter[]

  // Behavior system relations (for BEHAVIOR parameters)
  behaviorTargets      BehaviorTarget[]
  behaviorMeasurements BehaviorMeasurement[]
  callerTargets        CallerTarget[] // Personalized targets computed by ADAPT specs
  callTargets          CallTarget[] // Per-call targets computed by ADAPT specs

  // Provenance: which BDDFeatureSet created this parameter (if any)
  sourceFeatureSetId String?
  sourceFeatureSet   BDDFeatureSet? @relation(fields: [sourceFeatureSetId], references: [id], onDelete: SetNull)

  // Registry fields - Parameter table is the single source of truth
  isCanonical   Boolean   @default(true) // Is this a canonical parameter (vs experimental)?
  deprecatedAt  DateTime? // When deprecated (null = active)
  replacedBy    String? // If deprecated, which parameter replaces it?
  aliases       String[]  @default([]) // Alternative names for this parameter
  defaultTarget Float     @default(0.5) // Default target value (0-1 scale)

  @@index([sourceFeatureSetId])
  @@index([isCanonical])
  @@index([deprecatedAt])
  @@index([domainGroup])
}

model ParameterMapping {
  id          String  @id @default(uuid())
  parameterId String
  targetType  String
  targetKey   String
  weight      Float?
  notes       String?

  parameter Parameter @relation(fields: [parameterId], references: [parameterId])

  createdAt DateTime @default(now())
}

model Tag {
  id        String   @id
  name      String   @unique // Human-readable name, used in UI filters
  slug      String?  @unique
  tone      String? // optional: neutral/info/success/warning/danger/brand
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parameters ParameterTag[]
}

model ParameterTag {
  id          String   @id
  parameterId String
  tagId       String
  createdAt   DateTime @default(now())

  parameter Parameter @relation(fields: [parameterId], references: [parameterId], onDelete: Cascade, onUpdate: Cascade)
  tag       Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([parameterId, tagId])
  @@index([tagId])
  @@index([parameterId])
}

// =========================
// ANALYSIS PROFILES + RUNS
// =========================

model AnalysisProfile {
  id          String   @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  // Locking mechanism - profile locks when compiled set is used
  usageCount   Int       @default(0) // Number of analysis runs using compiled sets from this profile
  isLocked     Boolean   @default(false)
  lockedAt     DateTime?
  lockedReason String? // e.g., "Used by compiled set 'v1.0 Full Analysis'"

  parameters   AnalysisProfileParameter[]
  runs         AnalysisRun[]
  compiledSets CompiledAnalysisSet[]

  @@map("ParameterSet") // Keep existing table name for backwards compatibility
}

model AnalysisProfileParameter {
  id                String @id @default(uuid())
  analysisProfileId String @map("parameterSetId")
  parameterId       String

  // Snapshot of parameter content at run-time
  definition         String?
  scaleType          String?
  directionality     String?
  interpretationLow  String?
  interpretationHigh String?

  // EQ-style configuration fields
  enabled       Boolean @default(true) // Whether this parameter is active in this profile
  weight        Float   @default(1.0) // 0.0-2.0 multiplier for importance
  biasValue     Float? // Optional bias adjustment (-1.0 to +1.0)
  thresholdLow  Float? // Optional: custom low threshold
  thresholdHigh Float? // Optional: custom high threshold

  createdAt DateTime @default(now())

  analysisProfile AnalysisProfile @relation(fields: [analysisProfileId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  parameter       Parameter       @relation(fields: [parameterId], references: [parameterId], onDelete: Restrict, onUpdate: Cascade)

  @@unique([analysisProfileId, parameterId])
  @@index([analysisProfileId])
  @@index([parameterId])
  @@map("ParameterSetParameter") // Keep existing table name
}

model AnalysisRun {
  id                String  @id @default(uuid())
  analysisProfileId String? @map("parameterSetId")
  compiledSetId     String? // Reference to compiled set used for this run

  // e.g. QUEUED | RUNNING | SUCCEEDED | FAILED
  status     String
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  metadata   Json? // Additional run metadata

  createdAt DateTime @default(now())

  analysisProfile AnalysisProfile?     @relation(fields: [analysisProfileId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  compiledSet     CompiledAnalysisSet? @relation(fields: [compiledSetId], references: [id])
  scores          CallScore[]

  @@index([analysisProfileId])
  @@index([compiledSetId])
  @@index([status])
}

// =========================
// COMPILED ANALYSIS SETS
// =========================
// A compiled set is a validated, enriched snapshot of an AnalysisProfile
// ready for production use. Once used, it locks the source profile.

enum CompilationStatus {
  DRAFT // Initial state, not yet compiled
  COMPILING // Compilation in progress
  READY // Validated and ready for use
  ERROR // Compilation failed
  SUPERSEDED // Replaced by a newer version
}

model CompiledAnalysisSet {
  id          String  @id @default(uuid())
  name        String
  description String?
  version     String  @default("1.0")

  // Source profile (locked when this set is used)
  analysisProfileId String
  analysisProfile   AnalysisProfile @relation(fields: [analysisProfileId], references: [id])

  // Compilation status
  status     CompilationStatus @default(DRAFT)
  compiledAt DateTime?
  compiledBy String? // User or system that compiled

  // Validation results
  validationErrors Json? // Array of { specId/parameterId, error, severity }
  validationPassed Boolean @default(false)

  // What's included (spec IDs from the profile)
  specIds String[] // AnalysisSpec IDs included in compilation

  // Enrichment / RAG context
  ragContext   String?  @db.Text // Assembled KB context for prompts
  kbChunksUsed String[] // IDs of KB chunks used for enrichment

  // Computed stats at compile time
  measureSpecCount Int @default(0)
  learnSpecCount   Int @default(0)
  parameterCount   Int @default(0)
  anchorCount      Int @default(0)

  // Version chain
  parentVersionId String?
  parentVersion   CompiledAnalysisSet?  @relation("VersionChain", fields: [parentVersionId], references: [id])
  childVersions   CompiledAnalysisSet[] @relation("VersionChain")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Runs using this compiled set
  runs AnalysisRun[]

  @@index([analysisProfileId])
  @@index([status])
}

// =========================
// DOMAINS (Caller Segmentation)
// =========================
// Domains represent distinct use cases or personas (Tutor, Support, Sales, Wellness)
// Each caller is assigned to exactly one domain
// Each domain has one PUBLISHED playbook at a time

model Domain {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "tutor", "support", "sales", "wellness"
  name        String // Human-readable name
  description String?

  // Default domain - new callers go here
  isDefault Boolean @default(false)

  // Status
  isActive Boolean @default(true)

  // Onboarding Configuration (merged from Persona concept)
  onboardingWelcome        String? // Custom welcome message for first call in this domain
  onboardingIdentitySpecId String? // Which identity spec to use (TUT-001, COMPANION-001, COACH-001)
  onboardingIdentitySpec   AnalysisSpec? @relation("DomainOnboardingIdentity", fields: [onboardingIdentitySpecId], references: [id])
  onboardingFlowPhases     Json? // Custom first-call flow phases (optional override of INIT-001 defaults)
  onboardingDefaultTargets Json? // Custom default behavior targets for first call

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  callers            Caller[] // Callers assigned to this domain
  playbooks          Playbook[] // Playbooks for this domain
  onboardingSessions OnboardingSession[] // Track onboarding per domain
  invites            Invite[] // Field tester invites locked to this domain
  subjects           SubjectDomain[] // Subjects taught in this domain
  assignedUsers      User[] @relation("AssignedUsers") // Users scoped to this domain
  cohortGroups       CohortGroup[] // Cohort groups in this domain
  channelConfigs     ChannelConfig[] // Delivery channel configs for this domain

  @@index([slug])
  @@index([isDefault])
  @@index([isActive])
  @@index([onboardingIdentitySpecId])
}

// =========================
// SEGMENTS (Communities, Domains, Cohorts)
// =========================

enum SegmentType {
  COMPANY // Multi-tenant: different companies using the system
  COMMUNITY // Caller communities within a company
  DOMAIN // Product domains or use cases
  COHORT // Behavioral cohorts (e.g., "high-anxiety callers")
}

model Segment {
  id          String      @id @default(uuid())
  name        String
  description String?
  type        SegmentType

  // Nested hierarchy - segments can contain sub-segments
  parentId String?
  parent   Segment?  @relation("SegmentHierarchy", fields: [parentId], references: [id])
  children Segment[] @relation("SegmentHierarchy")

  // Metadata
  metadata Json? // Flexible metadata (rules, criteria, etc.)
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  behaviorTargets  BehaviorTarget[]
  callerIdentities CallerIdentity[]

  @@index([type])
  @@index([parentId])
  @@index([isActive])
}

// =========================
// BEHAVIOR TARGETS (Agent Communication Goals)
// =========================
// Layered target system: SYSTEM → SEGMENT → CALLER
// Lower levels override higher levels

enum BehaviorTargetScope {
  SYSTEM // Global defaults (base layer)
  PLAYBOOK // Per-playbook overrides (set during playbook creation)
  SEGMENT // Per-segment (community/domain/cohort)
  CALLER // Per-individual caller (learned over time)
}

// Inheritance cascade: SYSTEM → PLAYBOOK → SEGMENT → CALLER
// Each level can override the previous. When resolving a target:
// 1. Start with SYSTEM default
// 2. If PLAYBOOK target exists for active playbook, use it
// 3. If SEGMENT target exists for caller's segment, use it
// 4. If CALLER target exists for this caller, use it

enum BehaviorTargetSource {
  SEED // Initial seed data
  LEARNED // Automatically learned from reward loop
  MANUAL // Manually set by operator
}

model BehaviorTarget {
  id String @id @default(uuid())

  // Which behavior parameter this targets
  parameterId String
  parameter   Parameter @relation(fields: [parameterId], references: [parameterId])

  // Scope determines inheritance level
  scope BehaviorTargetScope

  // Scope references (based on scope level):
  // - SYSTEM: all null
  // - PLAYBOOK: playbookId set
  // - SEGMENT: segmentId set
  // - CALLER: callerIdentityId set
  playbookId       String?
  playbook         Playbook?       @relation(fields: [playbookId], references: [id])
  segmentId        String?
  segment          Segment?        @relation(fields: [segmentId], references: [id])
  callerIdentityId String?         @map("callerId")
  callerIdentity   CallerIdentity? @relation(fields: [callerIdentityId], references: [id])

  // Target value (0.0 - 1.0 for most behavioral parameters)
  targetValue Float

  // Confidence in this target (higher = more certain, affects learning rate)
  confidence Float @default(0.5)

  // How this target was established
  source BehaviorTargetSource @default(SEED)

  // Versioning - targets can change over time
  effectiveFrom  DateTime  @default(now())
  effectiveUntil DateTime? // null = currently active
  supersededById String? // Points to newer target if superseded

  // Learning metadata
  observationCount Int       @default(0) // How many observations informed this
  lastLearnedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([parameterId])
  @@index([scope])
  @@index([playbookId])
  @@index([segmentId])
  @@index([callerIdentityId], map: "BehaviorTarget_callerId_idx")
  @@index([effectiveFrom])
  @@index([effectiveUntil])
}

// =========================
// BEHAVIOR MEASUREMENT (What Agent Actually Did)
// =========================
// Records actual agent behavior per call for comparison with targets

model BehaviorMeasurement {
  id     String @id @default(uuid())
  callId String
  call   Call   @relation(fields: [callId], references: [id], onDelete: Cascade)

  // Which behavior parameter was measured
  parameterId String
  parameter   Parameter @relation(fields: [parameterId], references: [parameterId])

  // What the agent actually did
  actualValue Float

  // Confidence in this measurement
  confidence Float @default(0.7)

  // Evidence supporting this measurement
  evidence String[] // Quotes from transcript showing this behavior

  // Measurement metadata
  measuredAt DateTime @default(now())
  measuredBy String? // Agent/model that made measurement (e.g., "measure_agent_v1")

  createdAt DateTime @default(now())

  @@unique([callId, parameterId])
  @@index([callId])
  @@index([parameterId])
  @@index([measuredAt])
}

// =========================
// INSTITUTIONS
// =========================
// An institution represents a school, university, or organization.
// Provides branding (logo, colors, welcome message) for the educator portal + join pages.

model Institution {
  id             String  @id @default(uuid())
  name           String
  slug           String  @unique
  logoUrl        String?
  primaryColor   String? // Hex color for accent (e.g., "#4f46e5")
  secondaryColor String? // Hex color for hover/secondary accent
  welcomeMessage String? // Custom welcome text for join pages
  terminology    Json?   // Per-institution terminology overrides (TerminologyConfig)
  isActive       Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users        User[]
  cohortGroups CohortGroup[]

  @@index([slug])
}

// SYSTEM USERS & CALLERS
// =========================
// "User" = Admin/operator accounts who use this system
// "Caller" = End-users who interact with the AI agent (customers, students, contacts)

enum UserRole {
  SUPERADMIN // Level 5 — full system access, all entities, all config
  ADMIN // Level 4 — operational admin, broad access, no system internals
  OPERATOR // Level 3 — kept for backward compat, operational access
  EDUCATOR // Level 3 — educator portal, own cohorts + students only
  SUPER_TESTER // Level 2 — enhanced testing, domain-scoped data
  TESTER // Level 1 — basic testing, own data only
  STUDENT // Level 1 — student portal, own data only
  DEMO // Level 0 — guided demo experience, read-only subset
  VIEWER // @deprecated — alias for TESTER (kept for data migration compat)
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  emailVerified DateTime? // For NextAuth
  passwordHash  String? // For password auth (optional)
  role          UserRole  @default(OPERATOR) // Default to OPERATOR for new users
  name          String?
  displayName   String? // What the system calls this user
  image         String? // For NextAuth (avatar)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // Messaging relations
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")

  // Ticketing relations
  createdTickets  Ticket[]        @relation("CreatedTickets")
  assignedTickets Ticket[]        @relation("AssignedTickets")
  ticketComments  TicketComment[] @relation("TicketComments")

  // AI Task Guidance
  tasks UserTask[] @relation("UserTasks")

  // Domain scope (for TESTER/SUPER_TESTER — null means all domains)
  assignedDomainId String?
  assignedDomain   Domain? @relation("AssignedUsers", fields: [assignedDomainId], references: [id])

  // Institution scope (null = no institution)
  institutionId String?
  institution   Institution? @relation(fields: [institutionId], references: [id])

  // Field tester → Caller link
  callers Caller[]

  // Invites sent by this user (educator → student chain)
  sentInvites Invite[] @relation("SentInvites")

  // Media uploads
  mediaUploads MediaAsset[]

  @@index([email])
  @@index([role])
  @@index([assignedDomainId])
  @@index([institutionId])
}

// Note: AuditLog has userId but no FK constraint (logs persist after user deletion)

// NextAuth required models
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Invite system - control who can sign up
model Invite {
  id        String    @id @default(uuid())
  email     String    @unique
  token     String    @unique @default(uuid())
  role      UserRole  @default(OPERATOR) // Role to assign on signup
  expiresAt DateTime
  usedAt    DateTime? // Null until used
  createdBy String? // User who created the invite
  createdAt DateTime  @default(now())

  // Field tester invite fields
  firstName String? // Pre-fill name on accept form
  lastName  String? // Pre-fill name on accept form
  domainId  String? // Lock tester to specific domain (null = domain chooser)
  domain    Domain? @relation(fields: [domainId], references: [id])
  sentAt    DateTime? // When invite email was sent

  // Educator invite extensions
  cohortGroupId String? // Auto-assign student to cohort on accept
  cohortGroup   CohortGroup? @relation(fields: [cohortGroupId], references: [id])
  callerRole    CallerRole? // Create Caller with this role on accept (TEACHER or LEARNER)
  invitedById   String? // Track invitation chain (User ID who sent the invite)
  invitedBy     User?        @relation("SentInvites", fields: [invitedById], references: [id])

  @@index([token])
  @@index([email])
  @@index([domainId])
  @@index([cohortGroupId])
}

model Caller {
  id         String  @id @default(uuid())
  email      String?
  name       String?
  phone      String?
  externalId String? @unique

  // Caller role — determines function in the learning platform
  role CallerRole @default(LEARNER)

  // User link - for field testers who accepted an invite
  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  // Domain assignment - each caller belongs to exactly one domain
  domainId          String?
  domain            Domain? @relation(fields: [domainId], references: [id])
  previousDomainId  String? // Track last domain for re-onboarding detection
  domainSwitchCount Int     @default(0) // Number of times caller switched domains

  // Cohort group membership (for pupils in a teacher's group)
  cohortGroupId String?
  cohortGroup   CohortGroup? @relation("CohortMembers", fields: [cohortGroupId], references: [id])

  // Direct supervisor (for 1-1 tutor relationships without a formal group)
  supervisorCallerId String?
  supervisorCaller   Caller?  @relation("SupervisedCallers", fields: [supervisorCallerId], references: [id])
  supervisedCallers  Caller[] @relation("SupervisedCallers")

  // Cohort groups this caller owns (for teachers/tutors)
  ownedCohorts CohortGroup[] @relation("OwnedCohorts")

  // Relations
  personality             CallerPersonality?
  personalityProfile      CallerPersonalityProfile? // Extended profile with all parameters
  personalityObservations PersonalityObservation[]
  calls                   Call[]
  promptSlugSelections    PromptSlugSelection[]

  // Memory system
  memories      CallerMemory[]
  memorySummary CallerMemorySummary?

  // Call scoring
  callScores CallScore[]

  // CallerIdentities (phone numbers, etc.) linked to this caller
  callerIdentities CallerIdentity[]

  // AI-composed prompts for this caller
  composedPrompts ComposedPrompt[]

  // Personalized behavior targets (computed by ADAPT specs)
  callerTargets CallerTarget[]

  // Caller-specific attributes (curriculum progress, session state, etc.)
  callerAttributes CallerAttribute[]

  // Caller's goals (learn, achieve, connect, etc.)
  goals Goal[]

  // Playbook enrollments — explicit links to specific playbooks (class roster)
  enrollments CallerPlaybook[]

  // Conversation artifacts (content shared after calls)
  artifacts       ConversationArtifact[]
  actions         CallAction[]
  inboundMessages InboundMessage[]
  artifactConsent Boolean @default(true) // true for sim, explicit opt-in for WhatsApp

  // Onboarding tracking per domain
  onboardingSessions OnboardingSession[]

  // Archive: null = active, non-null = archived with timestamp
  archivedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([externalId])
  @@index([domainId])
  @@index([previousDomainId])
  @@index([archivedAt])
  @@index([role])
  @@index([cohortGroupId])
  @@index([supervisorCallerId])
}

// ExcludedCaller - Phone numbers/IDs to skip during transcript import
// Used when deleting spam callers or test data that shouldn't be re-imported
model ExcludedCaller {
  id         String   @id @default(uuid())
  phone      String? // Phone number to exclude
  externalId String? // External ID to exclude
  reason     String? // Optional reason for exclusion
  createdAt  DateTime @default(now())

  @@unique([phone])
  @@unique([externalId])
  @@index([phone])
  @@index([externalId])
}

// =========================
// COHORT GROUPS (Teacher/Tutor cohorts)
// =========================
// A cohort group is a set of callers supervised by a teacher or tutor.
// The owner (teacher/tutor) gets a dashboard showing pupil activity and progress.

model CohortGroup {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Domain scope — cohort belongs to one domain
  domainId String
  domain   Domain @relation(fields: [domainId], references: [id])

  // Owner — the teacher/tutor Caller who manages this cohort
  ownerId String
  owner   Caller @relation("OwnedCohorts", fields: [ownerId], references: [id])

  // Settings
  maxMembers Int     @default(50)
  isActive   Boolean @default(true)

  // Magic join link — shareable URL token for students to self-enrol
  joinToken    String?   @unique
  joinTokenExp DateTime? // Optional expiry (null = no expiry)

  // Members
  members Caller[] @relation("CohortMembers")

  // Institution branding (null = no institution)
  institutionId String?
  institution   Institution? @relation(fields: [institutionId], references: [id])

  // Invites linked to this cohort
  invites Invite[]

  // Playbooks assigned to this cohort (courses this classroom teaches)
  playbooks CohortPlaybook[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([domainId])
  @@index([ownerId])
  @@index([isActive])
  @@index([institutionId])
}

// CallTarget - Per-call behavior targets computed by ADAPT specs
// These are computed for each call and then aggregated into CallerTargets
model CallTarget {
  id String @id @default(uuid())

  callId String
  call   Call   @relation(fields: [callId], references: [id], onDelete: Cascade)

  parameterId String
  parameter   Parameter @relation(fields: [parameterId], references: [parameterId])

  // Target value for this behavior parameter (0.0 - 1.0)
  targetValue Float

  // Confidence in this target (0.0 - 1.0)
  confidence Float @default(0.7)

  // Which spec computed this target
  sourceSpecSlug String?

  // Explanation of why this target was chosen
  reasoning String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([callId, parameterId], name: "callId_parameterId")
  @@index([callId])
  @@index([parameterId])
}

// CallerTarget - Personalized behavior targets computed by ADAPT specs
// These override static BehaviorTargets and adapt based on caller's characteristics
model CallerTarget {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  parameterId String
  parameter   Parameter @relation(fields: [parameterId], references: [parameterId])

  // Target value for this behavior parameter (0.0 - 1.0)
  targetValue Float

  // How many calls were used to compute this target
  callsUsed Int @default(0)

  // Confidence in this personalized target (0.0 - 1.0)
  confidence Float @default(0.5)

  // How quickly this target should decay/update with new data (in days)
  // Lower = adapts faster to recent behavior
  decayHalfLife Float @default(7.0)

  // When this target was last recomputed
  lastUpdatedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([callerId, parameterId])
  @@index([callerId])
  @@index([parameterId])
}

// CallerAttribute - Flexible key-value store for caller-specific data
// Used by various specs (curriculum, session planning, domain-specific state)
model CallerAttribute {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  // Attribute key (e.g., "current_module", "session_arc", "mastery_chapter_1")
  key String

  // Scope of this attribute (GLOBAL, SESSION, CURRICULUM, etc.)
  scope String @default("GLOBAL")

  // Optional domain categorization
  domain String?

  // Which spec created/updated this attribute
  sourceSpecSlug String?

  // Value type and storage (only one should be set based on valueType)
  valueType    String // "STRING" | "NUMBER" | "BOOLEAN" | "JSON"
  stringValue  String?
  numberValue  Float?
  booleanValue Boolean?
  jsonValue    Json?

  // Confidence in this attribute value (0.0 - 1.0)
  confidence Float @default(1.0)

  // Optional expiration
  validUntil DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([callerId, key, scope])
  @@index([callerId])
  @@index([key])
  @@index([scope])
  @@index([validUntil])
}

// Goal - Represents a caller's objective (learn, achieve, connect, etc.)
// Goals are instantiated from playbook templates when caller joins a domain
// Can be tracked, updated, and completed over time
model Goal {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  // Origin tracking
  playbookId String? // Which playbook this goal came from (if template-based)
  playbook   Playbook? @relation(fields: [playbookId], references: [id])

  // Goal definition
  type        GoalType // LEARN, ACHIEVE, CHANGE, CONNECT, SUPPORT, CREATE
  name        String // "Master Quantum Mechanics"
  description String? // Detailed description of the goal
  status      GoalStatus @default(ACTIVE) // ACTIVE, COMPLETED, PAUSED, ARCHIVED

  // Implementation link (for LEARN goals, points to curriculum)
  contentSpecId String? // For LEARN goals -> links to CONTENT spec
  contentSpec   AnalysisSpec? @relation(fields: [contentSpecId], references: [id])

  // Progress tracking
  progress        Float @default(0) // 0.0 - 1.0 overall progress
  progressMetrics Json? // Type-specific progress data (modules completed, milestones reached, etc.)

  // Metadata
  priority Int @default(5) // 1-10, higher = more important

  // Lifecycle timestamps
  startedAt   DateTime?
  completedAt DateTime?
  targetDate  DateTime? // Optional deadline

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([callerId, status])
  @@index([type])
  @@index([status])
  @@index([playbookId])
}

// CallerPlaybook — Explicit enrollment of a caller in a specific playbook.
// Replaces the implicit "caller inherits all domain playbooks" pattern.
// Organisers manage class rosters by enrolling callers in specific playbooks.
model CallerPlaybook {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  playbookId String
  playbook   Playbook @relation(fields: [playbookId], references: [id])

  status CallerPlaybookStatus @default(ACTIVE)

  // Lifecycle timestamps
  enrolledAt  DateTime  @default(now())
  completedAt DateTime?
  pausedAt    DateTime?
  droppedAt   DateTime?

  // Source tracking — how this enrollment was created
  enrolledBy String? // "quick-launch" | "invite" | "auto" | "manual" | "migration"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([callerId, playbookId])
  @@index([callerId, status])
  @@index([playbookId])
}

// CohortPlaybook — Links a classroom (CohortGroup) to specific playbooks (courses).
// When students join the cohort, they auto-enroll in these playbooks.
// If a cohort has no CohortPlaybook records, falls back to domain-wide enrollment.
model CohortPlaybook {
  id String @id @default(uuid())

  cohortGroupId String
  cohortGroup   CohortGroup @relation(fields: [cohortGroupId], references: [id], onDelete: Cascade)

  playbookId String
  playbook   Playbook @relation(fields: [playbookId], references: [id])

  // Who assigned this playbook to the cohort
  assignedBy String? // "auto" | "manual" | "quick-launch" | userId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cohortGroupId, playbookId])
  @@index([cohortGroupId])
  @@index([playbookId])
}

// OnboardingSession - Tracks onboarding completion per caller per domain
// Supports domain switching with optional re-onboarding
model OnboardingSession {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  domainId String
  domain   Domain @relation(fields: [domainId], references: [id])

  // Onboarding state
  currentPhase    String? // "welcome", "orient", "discover", "sample", "close"
  completedPhases Json    @default("[]") // Array of {phase, completedAt, duration}
  isComplete      Boolean @default(false)
  wasSkipped      Boolean @default(false)

  // First call in this domain
  firstCallId String?
  firstCall   Call?   @relation(fields: [firstCallId], references: [id])

  // Metrics
  discoveredGoals   Int   @default(0)
  successMetricsMet Json? // Track INIT-001 success metrics

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@unique([callerId, domainId]) // One onboarding session per caller per domain
  @@index([callerId])
  @@index([domainId])
  @@index([isComplete])
}

model Call {
  id         String   @id @default(uuid())
  source     String
  externalId String?
  transcript String
  createdAt  DateTime @default(now())

  // Caller tracking
  callerId String?

  caller Caller? @relation(fields: [callerId], references: [id])

  // Call sequencing for delta calculations
  // Links to the previous call for this caller (for computing ADAPT parameters)
  previousCallId String?
  previousCall   Call?   @relation("CallSequence", fields: [previousCallId], references: [id])
  nextCalls      Call[]  @relation("CallSequence")
  callSequence   Int? // 1, 2, 3... for this caller's calls

  scores                 CallScore[]
  rewardScore            RewardScore?
  personalityObservation PersonalityObservation?
  promptSlugSelections   PromptSlugSelection[]

  // Memory extraction
  extractedMemories CallerMemory[]

  // Behavior measurements (what agent actually did)
  behaviorMeasurements BehaviorMeasurement[]

  // Prompts triggered by this call
  triggeredPrompts ComposedPrompt[] @relation("TriggeredPrompts")

  // The prompt that was active/used DURING this call
  // Set when the call is created, captures the state at call time
  usedPromptId String?
  usedPrompt   ComposedPrompt? @relation("UsedPrompt", fields: [usedPromptId], references: [id])

  // Per-call behavior targets (computed by ADAPT specs)
  callTargets CallTarget[]

  // Conversation artifacts extracted from this call
  artifacts ConversationArtifact[]

  // Call actions (actionable items from this call)
  actions CallAction[]

  // Onboarding tracking (if this call was the first in a domain)
  onboardingSessionsAsFirstCall OnboardingSession[]

  // Live observation
  endedAt  DateTime? // null = call may still be active (or pre-feature calls)
  messages CallMessage[]

  @@index([source])
  @@index([externalId])
  @@index([callerId], map: "Call_userId_idx")
  @@index([previousCallId])
  @@index([usedPromptId])
}

model CallMessage {
  id         String   @id @default(uuid())
  callId     String
  call       Call     @relation(fields: [callId], references: [id], onDelete: Cascade)
  role       String // "user" | "assistant" | "teacher"
  content    String   @db.Text
  senderName String? // For teacher messages: "Mrs. Smith"
  createdAt  DateTime @default(now())

  // Optional media attachment
  mediaId String?
  media   MediaAsset? @relation(fields: [mediaId], references: [id], onDelete: SetNull)

  @@index([callId, createdAt])
  @@index([mediaId])
}

model CallScore {
  id            String  @id @default(uuid())
  analysisRunId String? // Optional - can be scored by agent without a run
  callId        String
  callerId      String? // Denormalized for efficient queries
  parameterId   String

  // Scoring result
  score      Float
  confidence Float    @default(0.5)
  evidence   String[] // Array of evidence quotes
  reasoning  String?  @db.Text // LLM's reasoning for the score

  // Spec-driven scoring
  analysisSpecId String? // Which AnalysisSpec was used
  scoredAt       DateTime @default(now())
  scoredBy       String? // "mock_v1", "llm_v1", "manual", etc.

  createdAt DateTime @default(now())

  // Relations
  run          AnalysisRun?  @relation(fields: [analysisRunId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  call         Call          @relation(fields: [callId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  caller       Caller?       @relation(fields: [callerId], references: [id], onDelete: SetNull)
  parameter    Parameter     @relation(fields: [parameterId], references: [parameterId], onDelete: Restrict, onUpdate: Cascade)
  analysisSpec AnalysisSpec? @relation(fields: [analysisSpecId], references: [id], onDelete: SetNull)

  @@unique([analysisRunId, callId, parameterId])
  @@index([analysisRunId])
  @@index([callId])
  @@index([parameterId])
  @@index([callerId], map: "CallScore_userId_idx")
  @@index([analysisSpecId])
  @@index([scoredAt])
}

// =========================
// KNOWLEDGE BASE (DOCS/KB)
// =========================

enum IngestionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

model KnowledgeDoc {
  id String @id @default(uuid())

  // Absolute or repo-relative path to the file that was ingested
  sourcePath String @unique

  // Best-effort title (e.g. from YAML frontmatter or first H1)
  title String?

  // Original full text (normalized)
  content String @db.Text

  // Optional metadata extracted from frontmatter or filename conventions
  meta Json?

  // Content hash to detect changes and avoid unnecessary re-index
  contentSha String

  // Ingestion tracking (for resumable processing)
  status         IngestionStatus @default(PENDING)
  ingestedAt     DateTime?
  chunksExpected Int? // Total chunks this doc should have
  chunksCreated  Int             @default(0)
  errorMessage   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  chunks KnowledgeChunk[]

  @@index([updatedAt])
  @@index([contentSha])
  @@index([status])
}

model KnowledgeChunk {
  id    String @id @default(uuid())
  docId String

  // Monotonic index within the document
  chunkIndex Int

  // Character offsets in the parent document content
  startChar Int
  endChar   Int

  // Chunk text that is used for retrieval
  content String

  // Optional future fields
  tokens Int?

  createdAt DateTime @default(now())

  doc            KnowledgeDoc             @relation(fields: [docId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  embedding      VectorEmbedding?
  parameterLinks ParameterKnowledgeLink[]

  @@unique([docId, chunkIndex])
  @@index([docId])
  @@index([chunkIndex])
}

// Vector embeddings for semantic search
model VectorEmbedding {
  id      String @id @default(uuid())
  chunkId String @unique

  // Vector data — pgvector native column for similarity search
  embedding     Unsupported("vector(1536)")?
  // Legacy BYTEA column (nullable, kept for backward compat during transition)
  embeddingData Bytes?

  // Embedding metadata
  model      String // "text-embedding-3-small", "text-embedding-3-large"
  dimensions Int // 1536, 3072, etc.

  createdAt DateTime @default(now())

  chunk KnowledgeChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@index([chunkId])
  @@index([model])
}

// Knowledge artifacts curated for specific parameters
enum ArtifactType {
  SCORING_GUIDE // "How to score openness from conversation"
  EXAMPLES // "Examples of high/low openness in calls"
  RESEARCH_SUMMARY // "Research findings on openness indicators"
  PROMPT_TEMPLATE // "LLM prompt template for scoring openness"
  CALIBRATION_DATA // "Benchmark examples with known scores"
}

model KnowledgeArtifact {
  id          String  @id @default(uuid())
  parameterId String? // Link to specific parameter

  // Artifact type and content
  type    ArtifactType
  title   String
  content String       @db.Text // Condensed, curated content

  // Source tracking
  sourceChunkIds String[] // Which chunks contributed to this artifact
  confidence     Float? // How confident are we in this artifact?

  // Metadata
  tags    String[] // ["openness", "high_indicators", "conversational"]
  version String   @default("1.0")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parameter Parameter? @relation(fields: [parameterId], references: [parameterId])

  @@index([parameterId])
  @@index([type])
}

// Junction table: Parameter ↔ Knowledge chunks (with relevance scores)
model ParameterKnowledgeLink {
  id             String @id @default(uuid())
  parameterId    String
  chunkId        String
  relevanceScore Float // How relevant is this chunk? (from vector similarity)

  parameter Parameter      @relation(fields: [parameterId], references: [parameterId])
  chunk     KnowledgeChunk @relation(fields: [chunkId], references: [id])

  createdAt DateTime @default(now())

  @@unique([parameterId, chunkId])
  @@index([parameterId])
  @@index([chunkId])
  @@index([relevanceScore])
}

// =========================
// TRANSCRIPT PROCESSING
// =========================

enum FileType {
  BATCH_EXPORT
  SINGLE_CALL
  CSV_EXPORT
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL // Some calls extracted, some failed
  FAILED // File-level failure (invalid JSON, unreadable, etc.)
}

enum FailedCallErrorType {
  NO_TRANSCRIPT // No transcript field found in call
  INVALID_FORMAT // Malformed call structure
  DUPLICATE // Call already exists (by externalId)
  DB_ERROR // Database write failure
  NO_CUSTOMER // Could not identify caller
  UNKNOWN // Other/unknown error
}

model ProcessedFile {
  id              String           @id @default(uuid())
  filename        String
  filepath        String
  fileHash        String           @unique
  fileType        FileType
  callCount       Int // Total calls found in file
  callsExtracted  Int              @default(0) // Successfully extracted
  callsFailed     Int              @default(0) // Failed to extract
  callersCreated  Int              @default(0) @map("usersCreated") // Callers created during processing
  sizeBytes       BigInt
  status          ProcessingStatus @default(PENDING)
  processedAt     DateTime?
  sourcePreserved Boolean          @default(true)
  errorMessage    String?

  failedCalls FailedCall[]
  createdAt   DateTime     @default(now())

  @@unique([filepath, filename])
}

// Individual failed call extractions for review/retry
model FailedCall {
  id              String              @id @default(uuid())
  processedFileId String
  callIndex       Int // Position in source file (0-based)
  externalId      String? // Call ID if available
  errorType       FailedCallErrorType
  errorMessage    String
  rawData         Json // The original call object that failed
  retryCount      Int                 @default(0)
  resolvedAt      DateTime? // When manually resolved/skipped

  processedFile ProcessedFile @relation(fields: [processedFileId], references: [id], onDelete: Cascade)
  createdAt     DateTime      @default(now())

  @@index([processedFileId])
  @@index([errorType])
  @@index([resolvedAt])
}

// =========================
// CALLER PERSONALITY & PROFILING
// =========================

// Personality observation from a single call (time series data)
// MIGRATED Feb 2026: Now uses dynamic parameterValues instead of hardcoded OCEAN
model PersonalityObservation {
  id       String @id @default(uuid())
  callerId String
  callId   String @unique

  // DYNAMIC PARAMETERS - stores ANY personality parameters from database
  // Format: { "B5-O": 0.75, "B5-C": 0.82, "VARK-VISUAL": 0.65, ... }
  parameterValues Json @default("{}")

  // LEGACY FIELDS - Deprecated Feb 2026, kept for backward compatibility only
  // Will be removed after data migration is complete
  openness          Float? // DEPRECATED: Use parameterValues["B5-O"] or parameterValues["PERS-OPENNESS"]
  conscientiousness Float? // DEPRECATED: Use parameterValues["B5-C"] or parameterValues["PERS-CONSCIENTIOUSNESS"]
  extraversion      Float? // DEPRECATED: Use parameterValues["B5-E"] or parameterValues["PERS-EXTRAVERSION"]
  agreeableness     Float? // DEPRECATED: Use parameterValues["B5-A"] or parameterValues["PERS-AGREEABLENESS"]
  neuroticism       Float? // DEPRECATED: Use parameterValues["B5-N"] or parameterValues["PERS-NEUROTICISM"]

  // Metadata
  observedAt  DateTime @default(now())
  confidence  Float? // How confident is this observation?
  decayFactor Float    @default(1.0) // Used for time-based decay

  caller Caller @relation(fields: [callerId], references: [id])
  call   Call   @relation(fields: [callId], references: [id])

  createdAt DateTime @default(now())

  @@index([callerId], map: "PersonalityObservation_userId_idx")
  @@index([callId])
  @@index([observedAt])
}

// Aggregated personality profile (computed from observations with decay)
model CallerPersonality {
  id       String @id @default(uuid())
  callerId String @unique

  // DYNAMIC PARAMETERS - stores ANY personality parameters from database
  // Format: { "B5-O": 0.75, "B5-C": 0.82, "VARK-VISUAL": 0.65, ... }
  parameterValues Json @default("{}")

  // LEGACY FIELDS - Deprecated Feb 2026, kept for backward compatibility only
  // Will be removed after data migration is complete
  openness          Float? // DEPRECATED: Use parameterValues["B5-O"] or parameterValues["PERS-OPENNESS"]
  conscientiousness Float? // DEPRECATED: Use parameterValues["B5-C"] or parameterValues["PERS-CONSCIENTIOUSNESS"]
  extraversion      Float? // DEPRECATED: Use parameterValues["B5-E"] or parameterValues["PERS-EXTRAVERSION"]
  agreeableness     Float? // DEPRECATED: Use parameterValues["B5-A"] or parameterValues["PERS-AGREEABLENESS"]
  neuroticism       Float? // DEPRECATED: Use parameterValues["B5-N"] or parameterValues["PERS-NEUROTICISM"]

  // Communication style preferences (derived from patterns)
  preferredTone   String? // casual, formal, professional
  preferredLength String? // brief, detailed, verbose
  technicalLevel  String? // novice, intermediate, expert

  // Aggregation metadata
  lastAggregatedAt DateTime?
  observationsUsed Int       @default(0)
  confidenceScore  Float? // 0-1: How confident are we in this profile?
  decayHalfLife    Int       @default(30) // Days until observation weight halves

  caller    Caller   @relation(fields: [callerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("UserPersonality") // Preserve existing table name
}

// Extended personality profile with all parameter values (not just Big 5)
// Used by PromptSlugComposer to look up any parameter value
model CallerPersonalityProfile {
  id       String @id @default(uuid())
  callerId String @unique

  // All parameter values as JSON object
  // { "B5-O": 0.72, "B5-C": 0.65, "engagement": 0.8, ... }
  parameterValues Json @default("{}")

  // When was this profile last computed
  lastUpdatedAt DateTime?

  // Source tracking
  callsUsed Int @default(0) // Number of calls that contributed
  specsUsed Int @default(0) // Number of specs that contributed

  caller    Caller   @relation(fields: [callerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("UserPersonalityProfile") // Preserve existing table name
}

// =========================
// CALLER MEMORY SYSTEM
// =========================

// Memory categories for extracted facts
enum MemoryCategory {
  FACT // Immutable facts: "lives in London", "works at Acme Corp"
  PREFERENCE // Caller preferences: "prefers email over phone", "likes brief answers"
  EVENT // Time-bound events: "asked about pricing on Jan 15", "complained about X"
  TOPIC // Topics discussed: "interested in product X", "mentioned competitor Y"
  RELATIONSHIP // Relationships: "has 2 kids", "reports to Sarah"
  CONTEXT // Situational context: "traveling next week", "in a meeting"
}

// Memory source type
enum MemorySource {
  EXTRACTED // Automatically extracted by analysis agent
  INFERRED // Inferred from patterns across calls
  STATED // Explicitly stated by caller
  CORRECTED // Caller or operator corrected a previous memory
}

// Individual memory entries extracted from calls
model CallerMemory {
  id       String  @id @default(uuid())
  callerId String
  callId   String? // Source call (null if inferred from multiple)

  // Memory classification
  category MemoryCategory
  source   MemorySource   @default(EXTRACTED)

  // Key-value structure
  key           String // e.g., "location", "job_title", "preference_contact_method"
  value         String // e.g., "London", "Software Engineer", "email"
  normalizedKey String? // Canonical key for deduplication

  // Context and evidence
  evidence String? // The excerpt from transcript that supports this
  context  String? // Additional context about the extraction

  // Confidence and decay
  confidence  Float     @default(0.8) // 0-1: How confident in this memory?
  decayFactor Float     @default(1.0) // Current decay weight
  expiresAt   DateTime? // Some memories expire (e.g., "traveling next week")

  // Version/contradiction handling
  supersededById String? // If corrected/updated, points to newer memory
  supersededBy   CallerMemory?  @relation("MemorySupersession", fields: [supersededById], references: [id])
  supersedes     CallerMemory[] @relation("MemorySupersession")

  // Metadata
  extractedAt DateTime  @default(now())
  extractedBy String? // Agent that extracted this (e.g., "memory_extractor_v1")
  verifiedAt  DateTime? // When a human/system verified this
  verifiedBy  String? // Who verified

  caller Caller @relation(fields: [callerId], references: [id])
  call   Call?  @relation(fields: [callId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([callerId], map: "UserMemory_userId_idx")
  @@index([callId])
  @@index([category])
  @@index([key])
  @@index([normalizedKey])
  @@index([extractedAt])
  @@index([confidence])
  @@map("UserMemory") // Preserve existing table name
}

// Aggregated memory summary per caller (like a "profile card")
model CallerMemorySummary {
  id       String @id @default(uuid())
  callerId String @unique

  // Aggregated memory counts by category
  factCount       Int @default(0)
  preferenceCount Int @default(0)
  eventCount      Int @default(0)
  topicCount      Int @default(0)

  // Key facts (denormalized for quick access)
  // These are the most confident, recent, relevant facts
  keyFacts Json @default("[]") // Array of {key, value, confidence}

  // Common topics/interests
  topTopics Json @default("[]") // Array of {topic, frequency, lastMentioned}

  // Preferences summary
  preferences Json @default("{}") // {contactMethod: "email", responseLength: "brief", ...}

  // Last activity
  lastMemoryAt     DateTime?
  lastAggregatedAt DateTime?

  caller    Caller   @relation(fields: [callerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("UserMemorySummary") // Preserve existing table name
}

// =========================
// PROMPT TEMPLATES
// =========================
// Templates for composing final prompts from analysis results.
// Used as the output stage in Playbooks.
// Supports Mustache-style variables: {{personality.openness}}, {{memories.facts}}, etc.

model PromptTemplate {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "tutor-default", "support-empathetic"
  name        String
  version     String  @default("1.0")
  description String?

  // Base system prompt with placeholders
  // Mustache variables: {{personality.*}}, {{memories.*}}, {{caller.*}}, {{domain.*}}
  systemPrompt String @db.Text

  // JSON structure for personality modifiers
  // { openness: { high: "...", low: "..." }, ... }
  personalityModifiers Json?

  // Template for injecting conversation context
  contextTemplate String? @db.Text

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Playbook items that use this template
  playbookItems PlaybookItem[]

  @@index([slug])
  @@index([isActive])
}

// =========================
// REWARD MODEL SCORING
// =========================

model RewardScore {
  id     String @id @default(uuid())
  callId String @unique

  // Overall reward score (-1.0 to +1.0)
  overallScore Float

  // Dimension scores (weighted components)
  clarityScore    Float?
  empathyScore    Float?
  resolutionScore Float?
  efficiencyScore Float?
  coherenceScore  Float?

  // Scoring metadata
  modelVersion String // Which reward model version
  scoredAt     DateTime @default(now())
  scoredBy     String? // Agent/human identifier

  // Extracted outcome signals
  customerSatisfaction Float? // 0-1 scale
  taskCompleted        Boolean?
  escalated            Boolean?
  followUpRequired     Boolean?

  // Link scoring to parameters used (legacy)
  parametersSnapshot Json? // Snapshot of parameter values at call time

  // === BEHAVIOR TARGET COMPARISON ===
  // Snapshot of merged effective targets used for this call
  effectiveTargets Json? // { parameterId: { targetValue, scope, source } }

  // Snapshot of actual agent behavior measurements
  actualBehavior Json? // { parameterId: { actualValue, confidence } }

  // Computed diff between targets and actuals
  parameterDiffs Json? // { parameterId: { target, actual, diff, withinTolerance } }

  // Outcome signals that inform reward calculation
  outcomeSignals Json? // { resolved, sentiment_delta, duration, csat, ... }

  // What target updates were applied as a result of this reward
  targetUpdatesApplied Json? // [{ parameterId, oldTarget, newTarget, reason }]

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@index([overallScore])
  @@index([scoredAt])
}

// =========================
// AGENT INSTANCES & RUNS
// =========================

enum AgentInstanceStatus {
  DRAFT
  PUBLISHED
  SUPERSEDED
  ARCHIVED
}

enum AgentRunStatus {
  QUEUED
  RUNNING
  OK
  ERROR
}

// Agent instance with draft/publish workflow
model AgentInstance {
  id String @id @default(uuid())

  // Reference to manifest agent (e.g., "knowledge_extractor")
  agentId String

  // Human-readable overrides (can override manifest)
  name        String?
  description String?

  // Version tracking
  version String @default("v1.0")

  // Status workflow
  status AgentInstanceStatus @default(DRAFT)

  // Settings snapshot (JSON - merged manifest defaults + overrides)
  settings Json @default("{}")

  // Content hash for change detection
  settingsHash String?

  // Version chain (for history)
  parentVersionId String?
  parentVersion   AgentInstance?  @relation("AgentVersionChain", fields: [parentVersionId], references: [id])
  childVersions   AgentInstance[] @relation("AgentVersionChain")

  // Timestamps
  createdAt   DateTime  @default(now())
  publishedAt DateTime?
  updatedAt   DateTime  @updatedAt

  // Track which runs used this instance
  runs AgentRun[]

  @@unique([agentId, version])
  @@index([agentId])
  @@index([status])
  @@index([parentVersionId])
}

// Persistent agent run history
model AgentRun {
  id String @id @default(uuid())

  // Which agent instance was used (nullable for legacy/manifest-only runs)
  agentInstanceId String?
  agentInstance   AgentInstance? @relation(fields: [agentInstanceId], references: [id])

  // Fallback: agentId if no instance
  agentId    String
  agentTitle String?

  // Execution details
  opid   String?
  dryRun Boolean @default(false)

  // Status and timing
  status     AgentRunStatus
  startedAt  DateTime       @default(now())
  finishedAt DateTime?

  // Output
  summary String?
  stdout  String? @db.Text
  stderr  String? @db.Text

  // Artifacts as JSON array
  artifacts Json @default("[]")

  createdAt DateTime @default(now())

  @@index([agentInstanceId])
  @@index([agentId])
  @@index([status])
  @@index([startedAt])
}

// =========================
// PROMPT SLUG SELECTION
// =========================

model PromptSlugSelection {
  id       String  @id @default(uuid())
  callId   String
  callerId String?

  // Selected prompt slug
  promptSlug String
  confidence Float // 0-1 confidence in selection
  reasoning  String? // Why this slug was selected

  // Personality snapshot at selection time
  personalitySnapshot Json? // Big 5 scores used for selection

  // Recent slugs context (to avoid repetition)
  recentSlugs Json? // Array of recently used slugs

  // Selection metadata
  selectedAt      DateTime @default(now())
  selectionMethod String   @default("rule-based") // rule-based, ml-model, etc.

  // Relations
  call   Call    @relation(fields: [callId], references: [id], onDelete: Cascade)
  caller Caller? @relation(fields: [callerId], references: [id])

  // Link to reward (populated after call ends)
  reward PromptSlugReward?

  @@index([callId])
  @@index([callerId], map: "PromptSlugSelection_userId_idx")
  @@index([promptSlug])
  @@index([selectedAt])
}

// Reward for a specific prompt slug selection
model PromptSlugReward {
  id          String @id @default(uuid())
  selectionId String @unique

  // Computed reward score (-1.0 to +1.0)
  rewardScore Float

  // Component scores that fed into reward
  components Json // { csat, duration, resolved, sentiment_delta, ... }

  // Source of reward signals
  explicitFeedback Json? // Agent/customer ratings
  implicitSignals  Json? // Call metrics
  derivedMetrics   Json? // AI-computed metrics

  createdAt DateTime @default(now())

  selection PromptSlugSelection @relation(fields: [selectionId], references: [id], onDelete: Cascade)

  @@index([selectionId])
  @@index([rewardScore])
  @@index([createdAt])
}

// =========================
// SPECIFICATIONS (formerly AnalysisSpec)
// =========================
// Unified system for defining what to analyze in calls:
// - MEASURE: Score behaviors against parameter anchors → CallScore
// - LEARN: Learn structured facts about the caller → CallerMemory
// - ADAPT: Curate prompt prep data based on analysis
//
// Specs are scoped by visibility:
// - CALLER: Analyze the caller (personality, memories, engagement)
// - DOMAIN: Domain-specific rules (persona, reward components)
// - SYSTEM: Global guardrails and safety rules

enum SpecificationScope {
  CALLER // Caller analysis specs (personality, memories, behavior)
  DOMAIN // Domain-specific specs (persona, reward)
  SYSTEM // System-wide specs (guardrails, safety)
}

enum AnalysisOutputType {
  MEASURE // Score caller behavior against parameter anchors → CallScore
  LEARN // Extract structured facts about caller → CallerMemory
  ADAPT // Compute deltas and goal progress → CallScore for ADAPT parameters
  MEASURE_AGENT // Score agent behavior against targets → BehaviorMeasurement
  AGGREGATE // Aggregate scores into personality profiles → CallerPersonality, CallerPersonalityProfile
  COMPOSE // Compose prompts from gathered context → ComposedPrompt
  REWARD // Compute reward scores from behavior measurements → RewardScore
  SUPERVISE // Enforce guardrails and safety bounds on computed values
}

// Spec type: differentiates system-wide specs from domain-specific specs
enum SpecType {
  SYSTEM // System-wide specs (applied globally)
  DOMAIN // Domain-specific specs
}

// Spec role: categorizes what the spec contributes to the pipeline
// Determines which UI editor to use and special treatment
enum SpecRole {
  // === META-SYSTEM (Controls runtime behavior) ===
  ORCHESTRATE // Flow/sequence control → Flow Builder UI (PIPELINE-001, INIT-001, SESSION-001, INJECT-001)

  // === DATA PROCESSING (Acts on data) ===
  EXTRACT // Measurement/learning → Standard spec editor (PERS-001, VARK-001, MEM-001, STYLE-001, SUPV-001)
  SYNTHESISE // Combine/transform → Formula Builder UI (COMP-001, LEARN-PROF-001, REW-001, ADAPT-*)

  // === VALIDATION (Enforces rules) ===
  CONSTRAIN // Bounds/guards → Rule Editor UI (GUARD-001, GUARD-VOICEMAIL-001)

  // === CONTENT (What to say/teach) ===
  IDENTITY // Agent personas → Standard spec editor (TUT-001, COACH-001, COMPANION-001)
  CONTENT // Curriculum → Standard spec editor (WNF-CONTENT-001, QM-CONTENT-001)
  VOICE // Voice guidance → Standard spec editor (VOICE-001)

  // === DEPRECATED (Legacy roles - migrate to above) ===
  MEASURE // DEPRECATED: Use EXTRACT instead
  ADAPT // DEPRECATED: Use SYNTHESISE instead
  REWARD // DEPRECATED: Use SYNTHESISE instead
  GUARDRAIL // DEPRECATED: Use CONSTRAIN instead
  BOOTSTRAP // DEPRECATED: Use ORCHESTRATE instead
}

// =========================
// BDD FEATURE SETS
// =========================
// Stores parsed BDD spec files for compilation and activation
// The rawSpec field is the source of truth for runtime compilation

model BDDFeatureSet {
  id          String  @id @default(uuid())
  featureId   String  @unique // e.g., "PERS-001", "MEM-001"
  name        String
  description String? @db.Text

  // Spec metadata
  version  String @default("1.0")
  specType String @default("DOMAIN") // DOMAIN, SYSTEM, etc.

  // Parsed spec data (JSON)
  parameters     Json @default("[]")
  constraints    Json @default("[]")
  definitions    Json @default("{}")
  validations    Json @default("[]")
  promptGuidance Json @default("{}")
  thresholds     Json @default("[]")

  // Raw JSON spec (source of truth for compilation)
  rawSpec Json?

  // Scoring spec metadata (extracted from raw spec)
  scoringSpec Json?

  // Stats
  parameterCount  Int @default(0)
  constraintCount Int @default(0)
  definitionCount Int @default(0)

  // Activation status
  isActive    Boolean   @default(false)
  activatedAt DateTime?

  // Reverse relations: entities created by this feature set
  createdSpecs       AnalysisSpec[]
  createdParameters  Parameter[]
  createdPromptSlugs PromptSlug[]
  createdAnchors     ParameterScoringAnchor[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([featureId])
  @@index([isActive])
}

model BDDUpload {
  id       String  @id @default(uuid())
  filename String
  content  String  @db.Text
  status   String  @default("pending") // pending, processing, completed, error
  error    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// =========================
// CURRICULUM (Content Specs)
// =========================
// Stores curriculum/content data extracted from CONTENT specs
// Used by compose-prompt to inject content knowledge into prompts

model Curriculum {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "wnf-content-001"
  name        String
  description String? @db.Text

  // Source metadata
  authors     String[] // e.g., ["Daron Acemoglu", "James A. Robinson"]
  sourceTitle String? // e.g., "Why Nations Fail"
  sourceYear  Int?

  // Content structure (JSON)
  notableInfo         Json? // Notable information about the source
  coreArgument        Json? // Main thesis and key insights
  caseStudies         Json? // Case studies and examples
  discussionQuestions Json? // Discussion questions for teaching
  critiques           Json? // Scholarly critiques and counterpoints
  deliveryConfig      Json? // How to deliver this content (timing, pacing, etc.)

  // Constraints from spec
  constraints Json @default("[]")

  // Link to source AnalysisSpec
  sourceSpecId String?

  // Versioning
  version String @default("1.0")

  // === Content Trust & Source Authority ===
  trustLevel         ContentTrustLevel @default(UNVERIFIED)
  primarySourceId    String?           // FK to ContentSource (main authority for this curriculum)
  primarySource      ContentSource?    @relation("CurriculumPrimarySource", fields: [primarySourceId], references: [id], onDelete: SetNull)
  qualificationBody  String?           // "CII", "Highfield", "Ofqual"
  qualificationNumber String?          // "603/4937/2" or "R04"
  qualificationLevel String?           // "Level 2", "Diploma", "Certificate"
  validFrom          DateTime?         // When this curriculum version becomes active
  validUntil         DateTime?         // When this curriculum version expires

  // Subject linkage
  subjectId String?
  subject   Subject? @relation(fields: [subjectId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([sourceSpecId])
  @@index([trustLevel])
  @@index([validUntil])
  @@index([subjectId])
}

// Top-level spec: defines a category of analysis
// e.g., "Personality - Openness", "Memory - Personal Facts"
// Also known as "Specification" - AnalysisSpec is the legacy name (preserved via @@map)
model AnalysisSpec {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "personality-openness", "memory-personal-facts"
  name        String // Human-readable title
  description String? @db.Text // Full description with context

  // === SCOPE ===
  // Determines visibility and where this spec can be used
  // SYSTEM = global specs set by System Admin
  // DOMAIN = domain-specific specs set by Domain Admin
  // CALLER = auto-generated by learning system only (never manually created)
  scope SpecificationScope @default(DOMAIN)

  // What this spec produces
  outputType AnalysisOutputType @default(MEASURE)

  // Spec classification
  specType SpecType @default(DOMAIN) // SYSTEM or DOMAIN
  specRole SpecRole @default(EXTRACT) // What the spec contributes to the pipeline (changed default from MEASURE to EXTRACT)

  // Domain grouping (personality, memory, engagement, etc.)
  domain   String? // e.g., "personality", "memory", "engagement"
  priority Int     @default(0) // Higher = more important
  isActive Boolean @default(true)

  // Base agent reference — for overlay IDENTITY specs that extend a base archetype
  // Value is the spec ID (e.g., "TUT-001"). Prompt composition merges base + overlay at runtime.
  extendsAgent String?

  // Deletion control - prevents accidental deletion of critical specs
  isDeletable Boolean @default(true) // ORCHESTRATE specs (PIPELINE-001, INIT-001) should be false

  // Versioning
  version String @default("1.0")

  // Compilation status tracking
  compiledAt    DateTime? // When this spec was last compiled
  compiledSetId String? // Which compiled set includes this spec (deprecated - use sourceFeatureSetId)
  isDirty       Boolean   @default(true) // True if spec changed since last compile
  dirtyReason   String? // What changed: "trigger_added", "action_modified", etc.

  // Provenance: which BDDFeatureSet created this spec (if any)
  sourceFeatureSetId String?
  sourceFeatureSet   BDDFeatureSet? @relation(fields: [sourceFeatureSetId], references: [id], onDelete: SetNull)

  // Locking (when used by callers)
  isLocked     Boolean   @default(false)
  lockedAt     DateTime?
  lockedReason String? // e.g., "Used by 5 callers"
  usageCount   Int       @default(0) // Number of callers using this spec

  // === PROMPT TEMPLATE ===
  // Template text with Mustache-style variables that gets rendered at prompt composition time
  // Variables: {{value}}, {{label}}, {{param.name}}, {{memories.facts}}, {{user.name}}
  // Conditionals: {{#if high}}...{{/if}}, {{#if low}}...{{/if}}
  promptTemplate String? @db.Text

  // === CONFIGURATION ===
  // JSON configuration for this spec type. Schema depends on outputType:
  //
  // AGGREGATE config: {
  //   "traitMapping": {"B5-O": "openness", ...},
  //   "halfLifeDays": 30,
  //   "defaultConfidence": 0.7
  // }
  //
  // COMPOSE config: {
  //   "thresholds": {"high": 0.7, "low": 0.3},
  //   "maxTokens": 1500,
  //   "temperature": 0.7,
  //   "memoriesLimit": 50,
  //   "recentCallsLimit": 5
  // }
  //
  // REWARD config: {
  //   "outcomeWeights": {"resolved": 0.5, "escalated": -0.5},
  //   "behaviorWeight": 0.4,
  //   "outcomeWeight": 0.6,
  //   "tolerance": 0.15
  // }
  config Json?

  // Optional: link to existing PromptSlug for backwards compatibility
  promptSlugId String?
  promptSlug   PromptSlug? @relation(fields: [promptSlugId], references: [id])

  triggers AnalysisTrigger[]

  // CallScores produced by this spec
  callScores CallScore[]

  // Playbook items that reference this spec
  playbookItems PlaybookItem[]

  // Goals that use this spec as content (for LEARN goals with curriculum)
  goals Goal[]

  // Domains using this spec for onboarding identity (TUT-001, COMPANION-001, etc.)
  domainsUsingForOnboarding Domain[] @relation("DomainOnboardingIdentity")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([scope])
  @@index([domain])
  @@index([outputType])
  @@index([specType])
  @@index([specRole])
  @@index([isActive])
  @@index([compiledSetId])
  @@index([sourceFeatureSetId])
  @@index([isLocked])
  @@index([extendsAgent])
  // Keep old name as map for migration compatibility
  @@map("BddFeature")
}

// Trigger: when to apply this analysis (Given/When/Then structure)
// e.g., "Caller returns after 2+ week break", "Caller mentions personal info"
model AnalysisTrigger {
  id     String @id @default(uuid())
  specId String @map("featureId")

  // Gherkin-style structure
  given String @db.Text // Context/precondition
  when  String @db.Text // Trigger/action
  then  String @db.Text // Expected outcome (summary)

  // Optional trigger metadata
  name  String? // Short name for UI
  notes String? @db.Text // Implementation notes

  // Ordering within spec
  sortOrder Int @default(0)

  spec    AnalysisSpec     @relation(fields: [specId], references: [id], onDelete: Cascade)
  actions AnalysisAction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([specId])
  @@map("BddScenario")
}

// Action: what to do when trigger matches
// For MEASURE: score against a Parameter
// For LEARN: learn facts and store in a MemoryCategory
model AnalysisAction {
  id        String @id @default(uuid())
  triggerId String @map("scenarioId")

  // What to look for / extract
  description String @db.Text

  // Weight for aggregation (MEASURE only)
  weight Float @default(1.0)

  // === MEASURE fields ===
  // Link to Parameter for scoring (optional - only for MEASURE)
  parameterId String?
  parameter   Parameter? @relation(fields: [parameterId], references: [parameterId])

  // === LEARN fields ===
  // What type of memory to create (optional - only for LEARN)
  learnCategory  MemoryCategory? @map("extractCategory") // FACT, PREFERENCE, EVENT, RELATIONSHIP, etc.
  learnKeyPrefix String?         @map("extractKeyPrefix") // Key prefix: "location", "person_", "prefers_"
  learnKeyHint   String?         @map("extractKeyHint") // Hint for key generation: "Learn the specific location name"

  // Ordering within trigger
  sortOrder Int @default(0)

  trigger AnalysisTrigger @relation(fields: [triggerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([triggerId])
  @@index([parameterId])
  @@map("BddAcceptanceCriteria")
}

// =========================
// PLAYBOOKS
// =========================
// A Playbook is a versioned bundle of Specifications + a PromptTemplate
// that defines the complete analysis and prompt generation pipeline for a domain.
//
// Workflow: DRAFT → PUBLISHED → ARCHIVED
// Only one PUBLISHED playbook per domain at a time.
// Callers always use their domain's current PUBLISHED playbook.

enum PlaybookStatus {
  DRAFT // Work in progress, can be edited
  PUBLISHED // Active and in use, locked
  ARCHIVED // Superseded by newer version
}

enum PlaybookItemType {
  SPEC // Reference to an AnalysisSpec (MEASURE, LEARN, or ADAPT)
  PROMPT_TEMPLATE // Reference to a PromptTemplate for output formatting
}

model Playbook {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Domain this playbook belongs to
  domainId String
  domain   Domain @relation(fields: [domainId], references: [id])

  // Stack order within domain (lower = higher priority, first wins on conflicts)
  sortOrder Int @default(0)

  // Status workflow
  status PlaybookStatus @default(DRAFT)

  // Version tracking
  version String @default("1.0")

  // Version chain - link to previous published version
  parentVersionId String?
  parentVersion   Playbook?  @relation("PlaybookVersionChain", fields: [parentVersionId], references: [id])
  childVersions   Playbook[] @relation("PlaybookVersionChain")

  // Publishing metadata
  publishedAt DateTime?
  publishedBy String? // User or system that published

  // Configuration (goals, settings, etc.)
  config Json? // Stores goals and other playbook configuration

  // Validation status (computed on publish)
  validationErrors Json? // Array of { itemId, error, severity }
  validationPassed Boolean @default(false)

  // Stats computed at publish time
  measureSpecCount Int @default(0)
  learnSpecCount   Int @default(0)
  adaptSpecCount   Int @default(0)
  parameterCount   Int @default(0) // Unique parameters across all specs

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Items in this playbook (ordered)
  items PlaybookItem[]

  // Behavior targets specific to this playbook (overrides SYSTEM defaults)
  behaviorTargets BehaviorTarget[]

  // Goals instantiated from this playbook template
  goals Goal[]

  // Caller enrollments — who is enrolled in this playbook (class roster)
  enrollments CallerPlaybook[]

  // Cohort assignments — which classrooms use this playbook (course)
  cohortAssignments CohortPlaybook[]

  @@index([domainId])
  @@index([domainId, sortOrder])
  @@index([status])
  @@index([parentVersionId])
}

// Item in a Playbook - either a Spec or a PromptTemplate
// Ordered: execution proceeds top-down
// Order matters: MEASURE → LEARN → ADAPT → PROMPT_TEMPLATE
model PlaybookItem {
  id         String @id @default(uuid())
  playbookId String

  // What type of item
  itemType PlaybookItemType

  // === GROUPING ===
  // Optional grouping for organizing items under categories (e.g., acceptance criteria)
  // Examples: "AC-1", "AC-2", "PIPELINE", "COMPOSE"
  groupId    String? // Group identifier (e.g., "AC-1")
  groupLabel String? // Display label (e.g., "Cognitive activation cadence")
  groupOrder Int? // Order of this group (for sorting groups)

  // === SPEC item ===
  specId String?
  spec   AnalysisSpec? @relation(fields: [specId], references: [id])

  // === PROMPT_TEMPLATE item ===
  promptTemplateId String?
  promptTemplate   PromptTemplate? @relation(fields: [promptTemplateId], references: [id])

  // Item state
  isEnabled Boolean @default(true)

  // Ordering within playbook (critical for execution order)
  sortOrder Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  playbook Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)

  @@index([playbookId])
  @@index([specId])
  @@index([promptTemplateId])
  @@index([sortOrder])
  @@index([groupId])
}

// =========================
// PARAMETER SCORING ANCHORS
// =========================

// Scoring Anchor: a concrete example that defines what a score means for a Parameter
// This is the CALIBRATION DATA - the AI sees these before scoring
// e.g., score=0.9 "Welcome back! I remember we were discussing X last time..."
// e.g., score=0.3 "Hi, how can I help you?"
model ParameterScoringAnchor {
  id          String @id @default(uuid())
  parameterId String

  // The example
  example String @db.Text // Transcript excerpt or synthetic example

  // The score this example represents
  score Float // The calibrated score for this example

  // Why this score? (helps AI understand the rubric)
  rationale String? @db.Text // "This scores 0.9 because it demonstrates warmth AND memory"

  // Signal markers (what to look for)
  positiveSignals String[] // ["references_previous", "warm_greeting", "uses_name"]
  negativeSignals String[] // ["generic_greeting", "no_memory_reference"]

  // Is this a canonical/gold-standard example?
  isGold Boolean @default(false)

  // Source tracking
  source String? // "synthetic", "real_call:abc123", "expert_created"

  // Provenance: which BDDFeatureSet created this anchor (if any)
  sourceFeatureSetId String?
  sourceFeatureSet   BDDFeatureSet? @relation(fields: [sourceFeatureSetId], references: [id], onDelete: SetNull)

  // Ordering (show lower scores first for calibration)
  sortOrder Int @default(0)

  parameter Parameter @relation(fields: [parameterId], references: [parameterId], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([parameterId])
  @@index([score])
  @@index([isGold])
  @@index([sourceFeatureSetId])
}

// Aggregated effectiveness stats per prompt slug + personality bucket
model PromptSlugStats {
  id String @id @default(uuid())

  // The slug being tracked
  promptSlug String

  // Personality bucket (e.g., "high_N", "high_E_low_N", "balanced")
  personalityBucket String

  // Aggregated metrics
  totalUses            Int   @default(0)
  avgReward            Float @default(0)
  successRate          Float @default(0) // % of positive rewards
  confidenceAdjustment Float @default(0) // Learned adjustment to base confidence

  // Time-windowed stats (last 30 days)
  recentUses      Int   @default(0)
  recentAvgReward Float @default(0)

  // Last updated
  updatedAt DateTime @updatedAt

  @@unique([promptSlug, personalityBucket])
  @@index([promptSlug])
  @@index([personalityBucket])
  @@index([avgReward])
}

// =========================
// PROMPT SLUG SYSTEM
// =========================
// Dynamic prompt composition based on parameter values, memories, and stacks
// Key concepts:
// - PromptBlock: Static prompt blocks (system prompts, safety, personas)
// - PromptSlug: Dynamic prompt fragments driven by parameter values
// - PromptStack: Ordered collection of blocks + slugs that compose into final prompt
// - "Last wins" override: Later items in stack override earlier guidance

enum PromptSlugSource {
  PARAMETER // Driven by a parameter value (e.g., openness score)
  MEMORY // Driven by user memory (e.g., preferences)
  COMPOSITE // Combines multiple sources
  ADAPT // Driven by ADAPT parameters (deltas, goals)
}

enum PromptSlugMode {
  ABSOLUTE // Uses current value (e.g., openness = 0.8)
  DELTA // Uses change from previous call (e.g., openness increased by 0.2)
  GOAL // Uses goal progress (current / target)
}

enum PromptStackStatus {
  DRAFT // Work in progress
  PUBLISHED // Active and can be used by callers
  ARCHIVED // Superseded by newer version
}

enum PromptStackItemType {
  BLOCK // Static prompt block
  SLUG // Dynamic slug driven by parameter/memory
  CALLER // Auto-generated from caller's memories
  AUTO_SLUGS // Auto-collect all relevant dynamic prompts for caller's parameters
}

// Static prompt blocks (system prompts, safety, personas)
// These are templates that don't change based on caller state
model PromptBlock {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "system-base", "safety-guardrails", "persona-friendly"
  name        String
  description String?

  // Block categorization
  category String // "system" | "safety" | "persona" | "instruction" | "custom"

  // The actual prompt content
  content String @db.Text

  // Status
  isActive Boolean @default(true)
  version  String  @default("1.0")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to stack items
  stackItems PromptStackItem[]

  @@index([category])
  @@index([isActive])
}

// Dynamic prompt slug driven by parameter values
// Maps parameter value ranges to specific prompt text
model PromptSlug {
  id          String  @id @default(uuid())
  slug        String  @unique // e.g., "openness-style", "memory-short-term"
  name        String
  description String?

  // What drives this slug
  sourceType PromptSlugSource

  // === PARAMETER source (many-to-many) ===
  // Parameters that drive this slug (can be multiple for COMPOSITE)
  parameters PromptSlugParameter[]

  // === MEMORY source ===
  memoryCategory String? // Which memory category to pull from (FACT, PREFERENCE, EVENT, TOPIC, RELATIONSHIP)
  memoryMode     String? // "latest" | "summary" | "all" | "count:N"

  // === MEMORY injection policy ===
  // Controls how much memory to inject and when
  memoryMaxItems        Int? // Max memories to include (null = use global default)
  memoryMinConfidence   Float? // Minimum confidence threshold (null = use global default 0.5)
  memoryKeyPattern      String? // Filter memories by key pattern (glob-style, e.g., "spouse_*")
  memoryDecayEnabled    Boolean @default(true) // Apply time-based decay weighting
  memorySummaryTemplate String? @db.Text // If set, summarize memories using this template
  memoryTrigger         String? // When to inject: "always" | "if_exists" | "on_topic" | "recent_only"

  // Value ranges that map to prompt text
  ranges PromptSlugRange[]

  // Fallback if no range matches
  fallbackPrompt String? @db.Text

  // Priority for conflict resolution (higher = more important)
  priority Int @default(0)

  // Status
  isActive Boolean @default(true)
  version  String  @default("1.0")

  // Provenance: which BDDFeatureSet created this slug (if any)
  sourceFeatureSetId String?
  sourceFeatureSet   BDDFeatureSet? @relation(fields: [sourceFeatureSetId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to stack items
  stackItems PromptStackItem[]

  // Relation to AnalysisSpecs that use this slug
  analysisSpecs AnalysisSpec[]

  @@index([sourceType])
  @@index([isActive])
  @@index([sourceFeatureSetId])
}

// Junction table: PromptSlug ↔ Parameter (many-to-many)
// Allows a single slug to be driven by multiple parameters
model PromptSlugParameter {
  id          String @id @default(uuid())
  slugId      String
  parameterId String

  // How this parameter influences the slug
  weight Float          @default(1.0) // Weight for composite evaluation
  mode   PromptSlugMode @default(ABSOLUTE) // ABSOLUTE or DELTA

  // Ordering (for evaluation priority)
  sortOrder Int @default(0)

  slug      PromptSlug @relation(fields: [slugId], references: [id], onDelete: Cascade)
  parameter Parameter  @relation(fields: [parameterId], references: [parameterId])

  createdAt DateTime @default(now())

  @@unique([slugId, parameterId])
  @@index([slugId])
  @@index([parameterId])
}

// Range definition for a prompt slug
// Maps value ranges to specific prompt output
model PromptSlugRange {
  id     String @id @default(uuid())
  slugId String

  // Value range (for numeric parameters)
  minValue Float? // >= this value (null = no lower bound)
  maxValue Float? // < this value (null = no upper bound)

  // For memory-based slugs, condition string
  condition String? // e.g., "has_value", "contains:X", "recent"

  // The prompt text for this range
  prompt String @db.Text

  // Human-readable label for this range
  label String? // e.g., "High openness", "Low engagement"

  // Optional metadata
  metadata Json?

  // Ordering (for display)
  sortOrder Int @default(0)

  slug PromptSlug @relation(fields: [slugId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slugId])
  @@index([sortOrder])
}

// =========================
// PROMPT COMPOSITION CONFIG
// =========================

// Global configuration for prompt composition
// System-wide defaults that can be overridden per-slug
model PromptCompositionConfig {
  id          String  @id @default(uuid())
  name        String  @unique // e.g., "default", "high-memory", "minimal"
  description String?

  // Memory injection defaults
  memoryMaxCount      Int      @default(20) // Max memories to inject globally
  memoryMinConfidence Float    @default(0.5) // Minimum confidence threshold
  memoryDecayEnabled  Boolean  @default(true) // Apply time-based decay weighting
  memoryCategories    String[] // Categories to include (empty = all)

  // Summarization settings
  memorySummarizeAbove Int? // If > N memories, summarize instead of listing
  memorySummaryPrompt  String? @db.Text // Template for summarization

  // Context-awareness settings
  memoryRelevanceMode String @default("all") // "all" | "topic-match" | "recent" | "weighted"
  memoryRecencyDays   Int? // For "recent" mode: only include memories from last N days

  // Prompt assembly settings
  slugSeparator   String  @default("\n\n") // How to join multiple slug outputs
  includeMetadata Boolean @default(false) // Include debug metadata in output

  // Status
  isActive  Boolean @default(true)
  isDefault Boolean @default(false) // Use this config when none specified

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@index([isDefault])
}

// Prompt stack: ordered collection of blocks + slugs
// Composed at runtime to produce the final prompt
model PromptStack {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Status workflow
  status PromptStackStatus @default(DRAFT)

  // Is this the default stack for new callers?
  isDefault Boolean @default(false)

  // Version chain
  version         String        @default("1.0")
  parentVersionId String?
  parentVersion   PromptStack?  @relation("StackVersionChain", fields: [parentVersionId], references: [id])
  childVersions   PromptStack[] @relation("StackVersionChain")

  // Usage tracking
  usageCount Int @default(0)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  // Items in this stack (ordered)
  items PromptStackItem[]

  // CallerIdentities using this stack
  callerIdentities CallerIdentity[]

  @@index([status])
  @@index([isDefault])
}

// Item in a prompt stack (block, slug, or caller content)
model PromptStackItem {
  id      String @id @default(uuid())
  stackId String

  // What type of item
  itemType PromptStackItemType

  // === BLOCK item ===
  blockId String?
  block   PromptBlock? @relation(fields: [blockId], references: [id])

  // === SLUG item ===
  slugId String?
  slug   PromptSlug? @relation(fields: [slugId], references: [id])

  // === CALLER item ===
  // Auto-generates content from caller's memories
  // Configure which memory categories to include
  callerMemoryCategories String[] // e.g., ["FACT", "PREFERENCE"]
  callerMemoryLimit      Int? // Max memories to include

  // === AUTO_SLUGS item ===
  // Auto-collect all relevant dynamic prompts based on caller's parameter values
  autoSlugSourceTypes  String[] // e.g., ["PARAMETER", "COMPOSITE"] - which source types to include
  autoSlugOrderBy      String? // "priority" | "domainGroup" | "name" - how to order collected prompts
  autoSlugLimit        Int? // Max slugs to include (null = unlimited)
  autoSlugDomainFilter String[] // Optional: only include slugs from these domains

  // Item state
  isEnabled Boolean @default(true)

  // Ordering (critical for "last wins" override)
  sortOrder Int @default(0)

  stack PromptStack @relation(fields: [stackId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stackId])
  @@index([blockId])
  @@index([slugId])
  @@index([sortOrder])
}

// =========================
// CALLER IDENTITY MODEL
// =========================
// Represents a contact identity (phone number, account ID) linked to a Caller
// Used for prompt composition and behavior targeting per identity

model CallerIdentity {
  id String @id @default(uuid())

  // Caller reference (the person this identity belongs to)
  callerId String?
  caller   Caller? @relation(fields: [callerId], references: [id])

  // External identifier (phone number, account ID, etc.)
  externalId String? @unique

  // Display name
  name String?

  // === SEGMENT ASSIGNMENT ===
  // Which segment this identity belongs to (for target inheritance)
  segmentId String?
  segment   Segment? @relation(fields: [segmentId], references: [id])

  // === PROMPT STATE ===
  // Which stack is assigned to this identity
  promptStackId String?
  promptStack   PromptStack? @relation(fields: [promptStackId], references: [id])

  // The composed prompt ready for the next call
  // This is the output of evaluating the stack against current state
  callerPrompt String? @db.Text

  // When was the prompt last composed
  promptComposedAt DateTime?

  // Snapshot of inputs used for last composition (for debugging/audit)
  promptSnapshot Json? // { parameterValues: {...}, memories: [...], stackVersion: "..." }

  // === NEXT CALL PREPARATION ===
  // Pre-composed prompt for the next call (output of reward loop)
  nextPrompt           String?   @db.Text
  nextPromptComposedAt DateTime?

  // Inputs that went into next prompt composition (for audit/debugging)
  nextPromptInputs Json? // { callerProfile, effectiveTargets, rewardHistory, ... }

  // === BEHAVIOR TARGETS ===
  // Identity-specific learned behavior targets
  behaviorTargets BehaviorTarget[]

  // === STATS ===
  callCount  Int       @default(0)
  lastCallAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([callerId])
  @@index([externalId])
  @@index([promptStackId])
  @@index([segmentId])
}

// =========================
// COMPOSED PROMPTS (AI-generated next-call prompts)
// =========================

// A prompt composed by AI for a specific caller, with history tracking
model ComposedPrompt {
  id       String @id @default(uuid())
  callerId String

  // The composed prompt text (human-readable prose)
  prompt String @db.Text

  // LLM-friendly structured prompt (JSON with explicit data, values, lists)
  // More reliable for AI consumption than prose
  llmPrompt Json?

  // What triggered this composition
  triggerType String // "manual" | "post_call" | "scheduled" | "analysis_complete"

  // Optional: which call triggered this composition
  triggerCallId String?
  triggerCall   Call?   @relation("TriggeredPrompts", fields: [triggerCallId], references: [id])

  // Calls that used this prompt (reverse of Call.usedPromptId)
  usedForCalls Call[] @relation("UsedPrompt")

  // Inputs used for composition (for audit/debugging)
  inputs Json? // { memories, personality, behaviorTargets, recentCalls, etc. }

  // AI model used
  model String? // e.g., "gpt-4", "claude-3"

  // Status tracking
  status String @default("active") // "active" | "superseded" | "expired"

  // Timestamps
  composedAt DateTime  @default(now())
  expiresAt  DateTime? // Optional expiration

  // Relations
  caller Caller @relation(fields: [callerId], references: [id])

  createdAt DateTime @default(now())

  @@index([callerId])
  @@index([composedAt])
  @@index([triggerCallId])
  @@index([status])
}

// =========================
// SYSTEM ADMIN LOGGING
// =========================

// System-wide error and event logging for administrators
model SystemLog {
  id       String @id @default(uuid())
  level    String // DEBUG, INFO, WARN, ERROR, CRITICAL
  category String // CURRICULUM, AI_PROVIDER, SPEC_PROCESSING, etc.
  message  String @db.Text
  context  Json? // Additional context data
  error    Json? // Error details (name, message, stack)

  // Request context
  requestId String?
  userId    String?
  callerId  String?

  // Timestamps
  timestamp DateTime @default(now())

  // Indexes for admin dashboard queries
  @@index([level])
  @@index([category])
  @@index([timestamp])
  @@index([callerId])
}

// =========================
// USAGE METERING SYSTEM
// =========================
// Tracks resource usage and costs across AI, Database, Compute, Storage, and External APIs
// Supports rollups for efficient period-based queries (hour/day/week/month)

enum UsageCategory {
  AI // LLM API calls (Claude, OpenAI)
  DATABASE // Expensive DB queries (>100ms)
  COMPUTE // CPU-intensive operations (pipeline runs, analysis)
  STORAGE // File storage operations
  EXTERNAL // Third-party API calls (webhooks, external services)
}

enum RollupPeriod {
  HOUR
  DAY
  WEEK
  MONTH
}

// Individual usage events - fine-grained tracking
model UsageEvent {
  id String @id @default(uuid())

  // Categorization
  category  UsageCategory
  operation String // e.g., "ai:claude:input", "db:Caller.findMany", "compute:pipeline"

  // Attribution
  userId   String? // Admin user who triggered this
  callerId String? // Related caller
  callId   String? // Related call

  // Quantity and cost
  quantity  Float  @default(1)
  unitType  String @default("count") // "tokens", "ms", "bytes", "count"
  costCents Float  @default(0) // Calculated cost in cents

  // Context
  engine   String? // "claude", "openai", "postgres"
  model    String? // "claude-sonnet-4", "gpt-4o"
  sourceOp String? // Which operation triggered this: "pipeline:run", "chat", "compose-prompt"
  metadata Json? // Additional context

  createdAt DateTime @default(now())

  @@index([category])
  @@index([operation])
  @@index([userId])
  @@index([callerId])
  @@index([createdAt])
  @@index([sourceOp])
}

// Pre-aggregated rollups for dashboard performance
model UsageRollup {
  id String @id @default(uuid())

  // Time period
  period      RollupPeriod
  periodStart DateTime // Start of the period (truncated hour/day/week/month)
  periodEnd   DateTime // End of the period

  // Dimensions
  category  UsageCategory
  operation String? // null = total for category
  userId    String? // null = all users

  // Aggregates
  eventCount Int   @default(0)
  totalQty   Float @default(0) // Sum of quantity
  totalCost  Float @default(0) // Sum of costCents

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([period, periodStart, category, operation, userId])
  @@index([period, periodStart])
  @@index([category])
  @@index([userId])
}

// Cost rate configuration (admin-editable)
// Allows customization of cost rates per category/operation
model UsageCostRate {
  id String @id @default(uuid())

  category  UsageCategory
  operation String? // null = default for category

  // Rate definition
  costPerUnit Float // Cost in cents per unit
  unitType    String // What unit: "tokens", "ms", "bytes", "count"

  // Validity period (for historical rates)
  effectiveFrom  DateTime  @default(now())
  effectiveUntil DateTime? // null = currently active

  // Metadata
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category, operation])
  @@index([effectiveFrom])
}

// =========================
// PIPELINE TRACING SYSTEM
// =========================
// Records execution traces for the LEARN and ADAPT pipelines
// Used for debugging, visualization, and understanding pipeline behavior

enum PipelinePhase {
  LEARN // Post-call analysis: transcripts → measure → memory → reward
  ADAPT // Pre-call preparation: compose prompt
}

enum PipelineStepStatus {
  PENDING // Queued but not started
  RUNNING // Currently executing
  SUCCESS // Completed successfully
  FAILED // Execution failed
  SKIPPED // Skipped (condition not met)
}

// Top-level pipeline execution record
// Groups all steps for a single pipeline invocation
model PipelineRun {
  id String @id @default(uuid())

  // Which pipeline phase this run belongs to
  phase PipelinePhase

  // Context: what triggered this run
  callerId    String?
  callId      String? // For LEARN phase: the call being analyzed
  triggeredBy String? // "manual" | "post_call" | "scheduled" | "api"

  // Overall status (computed from steps)
  status PipelineStepStatus @default(PENDING)

  // Timing
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  durationMs Int? // Total duration

  // Summary stats (computed at completion)
  stepsTotal     Int @default(0)
  stepsSucceeded Int @default(0)
  stepsFailed    Int @default(0)
  stepsSkipped   Int @default(0)

  // Error summary (if any step failed)
  errorSummary String?

  // Metadata
  metadata Json? // Additional context (e.g., dry run, version info)

  createdAt DateTime @default(now())

  // Steps in this run
  steps PipelineStep[]

  @@index([phase])
  @@index([callerId])
  @@index([callId])
  @@index([status])
  @@index([startedAt])
}

// Individual step execution within a pipeline run
// Records inputs, outputs, timing, and status for each operation
model PipelineStep {
  id    String @id @default(uuid())
  runId String

  // Step identification
  operation String // e.g., "transcripts:process", "personality:analyze"
  label     String? // Human-readable label

  // Ordering
  sortOrder Int @default(0)

  // Status and timing
  status     PipelineStepStatus @default(PENDING)
  startedAt  DateTime?
  finishedAt DateTime?
  durationMs Int?

  // === CONFIGURATION ===
  // Which spec configured this step (if data-driven)
  specId   String? // AnalysisSpec ID
  specSlug String? // Denormalized for display

  // === INPUTS ===
  // Snapshot of data that went into this step
  inputs      Json? // { transcript: "...", callerId: "..." }
  inputCounts Json? // { memories: 12, targets: 5 } - summary counts

  // === OUTPUTS ===
  // What this step produced
  outputs      Json? // { personality: {...}, memories: [...] }
  outputCounts Json? // { memoriesCreated: 4, scoresComputed: 8 }

  // Links to created records (for navigation)
  createdRecordIds Json? // { memories: ["id1", "id2"], scores: ["id3"] }

  // === ERROR HANDLING ===
  error      String? // Error message if failed
  errorStack String? @db.Text // Full stack trace

  // === COMPOSITION DETAILS ===
  // For COMPOSE steps: additional metadata about section processing
  sectionsActivated String[] // Which sections were included
  sectionsSkipped   String[] // Which sections were skipped (with reasons)
  sectionTimings    Json? // { personality: 12, memories: 45, ... } in ms

  run PipelineRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([runId])
  @@index([operation])
  @@index([status])
  @@index([specId])
}

// =========================
// AI CONFIGURATION
// =========================

// Configurable AI model settings for each call point in the system
// Allows admins to switch between providers/models per operation
model AIConfig {
  id String @id @default(uuid())

  // Unique identifier for the call point (e.g., "pipeline.measure", "pipeline.learn")
  callPoint String @unique

  // Human-readable label for the UI
  label String

  // AI Provider: claude, openai, mock
  provider String @default("claude")

  // Specific model ID (e.g., "claude-sonnet-4-20250514", "gpt-4o", "claude-3-haiku-20240307")
  model String

  // Optional overrides
  maxTokens       Int?
  temperature     Float?
  transcriptLimit Int? // Max chars of transcript to include in prompt (cost optimization)

  // Whether this config is active (allows disabling without deleting)
  isActive Boolean @default(true)

  // Metadata
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([provider])
  @@index([isActive])
}

// Available AI models that can be selected in AIConfig
// Stored in DB so admins can add/remove models without code changes
model AIModel {
  id String @id @default(uuid())

  // Model identifier used in API calls (e.g., "claude-sonnet-4-20250514", "gpt-4o")
  modelId String @unique

  // Provider this model belongs to
  provider String // claude, openai, mock

  // Human-readable label for the UI
  label String

  // Model tier for cost/capability indication
  tier String // flagship, standard, fast, test

  // Whether this model is available for selection
  isActive Boolean @default(true)

  // Sort order for UI display (lower = first)
  sortOrder Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([provider])
  @@index([isActive])
  @@index([provider, isActive])
}

// =========================
// SYSTEM SETTINGS
// =========================

// Key-value store for system-wide settings
model SystemSetting {
  id    String @id @default(uuid())
  key   String @unique // e.g., "audit_logging_enabled"
  value String // JSON-encoded value

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@index([key])
}

// =========================
// AUDIT LOGGING
// =========================

// Tracks who did what in the system
model AuditLog {
  id String @id @default(uuid())

  // Who performed the action
  userId    String?
  userEmail String? // Denormalized for quick display

  // What action was performed
  action String // e.g., "ran_pipeline", "created_caller", "updated_playbook"

  // What entity was affected
  entityType String? // e.g., "Call", "Caller", "Playbook"
  entityId   String? // ID of the affected entity

  // Additional context
  metadata Json? // Extra details (before/after values, etc.)

  // Request context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([createdAt])
}

// =========================
// MESSAGING SYSTEM
// =========================

model Message {
  id String @id @default(uuid())

  // Participants
  senderId    String
  sender      User   @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipientId String
  recipient   User   @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)

  // Content
  subject String?
  content String  @db.Text

  // Status
  readAt DateTime?

  // For threading (replies)
  parentId String?
  parent   Message?  @relation("MessageReplies", fields: [parentId], references: [id], onDelete: SetNull)
  replies  Message[] @relation("MessageReplies")

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([senderId])
  @@index([recipientId])
  @@index([parentId])
  @@index([readAt])
  @@index([createdAt])
}

// =========================
// TICKETING SYSTEM
// =========================

enum TicketStatus {
  OPEN // Newly created
  IN_PROGRESS // Being worked on
  WAITING // Waiting on requester
  RESOLVED // Issue resolved
  CLOSED // Ticket closed
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketCategory {
  BUG // Something is broken
  FEATURE // Feature request
  QUESTION // General question
  SUPPORT // Support request
  OTHER
}

model Ticket {
  id String @id @default(uuid())

  // Human-readable reference number
  ticketNumber Int @unique @default(autoincrement())

  // Creator and assignment
  creatorId  String
  creator    User    @relation("CreatedTickets", fields: [creatorId], references: [id], onDelete: Cascade)
  assigneeId String?
  assignee   User?   @relation("AssignedTickets", fields: [assigneeId], references: [id], onDelete: SetNull)

  // Content
  title       String
  description String @db.Text

  // Classification
  status   TicketStatus   @default(OPEN)
  priority TicketPriority @default(MEDIUM)
  category TicketCategory @default(OTHER)

  // Optional tags for flexible categorization
  tags String[]

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  resolvedAt DateTime?
  closedAt   DateTime?

  // Relations
  comments TicketComment[]

  @@index([creatorId])
  @@index([assigneeId])
  @@index([status])
  @@index([priority])
  @@index([category])
  @@index([createdAt])
  @@index([ticketNumber])
}

model TicketComment {
  id String @id @default(uuid())

  // Parent ticket
  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Author
  authorId String
  author   User   @relation("TicketComments", fields: [authorId], references: [id], onDelete: Cascade)

  // Content
  content String @db.Text

  // Internal notes (visible only to admins/operators)
  isInternal Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
}

// =========================
// AI KNOWLEDGE ACCUMULATION
// =========================

// Logs all AI interactions for learning and improvement
model AIInteractionLog {
  id String @id @default(uuid())

  // Where this interaction occurred
  callPoint String // 'spec.assistant', 'pipeline.measure', etc.

  // The interaction
  userMessage String @db.Text
  aiResponse  String @db.Text

  // Outcome classification
  outcome String // 'success', 'correction', 'failure'

  // Additional context
  metadata Json? // { entityType, entityId, action, corrections, etc. }

  // Timestamps
  createdAt DateTime @default(now())

  @@index([callPoint])
  @@index([outcome])
  @@index([createdAt])
}

// Patterns learned from successful interactions
model AILearnedPattern {
  id String @id @default(uuid())

  // The pattern (e.g., "create_spec_for_personality")
  pattern String

  // Where this pattern applies
  callPoint String

  // Optional domain
  domain String?

  // Confidence and frequency
  confidence  Float @default(0.5) // 0-1
  occurrences Int   @default(1)

  // Example interactions that demonstrate this pattern
  examples String[] // Array of example messages

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([pattern, callPoint])
  @@index([callPoint])
  @@index([domain])
  @@index([confidence])
  @@index([occurrences])
}

// =========================
// TASK GUIDANCE & FLASH SIDEBAR
// =========================

enum TaskStatus {
  in_progress
  completed
  abandoned
}

// Tracks user tasks for contextual guidance
model UserTask {
  id String @id @default(uuid())

  // User performing the task
  userId String
  user   User   @relation("UserTasks", fields: [userId], references: [id], onDelete: Cascade)

  // Task type (e.g., 'create_spec', 'configure_caller')
  taskType String

  // Task status
  status TaskStatus @default(in_progress)

  // Progress tracking
  currentStep    Int      @default(1)
  totalSteps     Int
  completedSteps String[] // Array of step IDs completed

  // Blockers preventing progress
  blockers String[] // Array of blocker descriptions

  // Additional context (user intent, entity IDs, etc.)
  context Json?

  // Timestamps
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  archivedAt  DateTime?
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([taskType])
  @@index([startedAt])
}

// =========================
// CONTENT TRUST & SOURCE AUTHORITY
// =========================
// Tracks authoritative sources for teaching content and traces
// every teaching point back to its provenance. Critical for regulated
// qualifications (CII, Highfield, etc.) where content fidelity matters.

// A registered source of authority (a book, syllabus, handbook)
model ContentSource {
  id          String @id @default(uuid())

  // Identification
  slug        String @unique // e.g., "cii-r04-syllabus-2025", "sprenger-food-safety-37th"
  name        String         // "CII R04 Syllabus 2025/26"
  description String? @db.Text

  // Trust classification
  trustLevel  ContentTrustLevel @default(UNVERIFIED)

  // Document classification
  documentType            DocumentType @default(TEXTBOOK)
  documentTypeSource      String?  // "ai:0.92" or "admin:manual" — provenance of classification
  textSample              String?  @db.Text  // First ~1000 chars for few-shot classification learning
  aiClassification        String?            // Original AI guess "TYPE:confidence" (never mutated after set)
  classificationCorrected Boolean  @default(false) // True when admin overrode AI's classification

  // Publisher / authority chain
  publisherOrg    String?  // "Chartered Insurance Institute", "Highfield Publications"
  accreditingBody String?  // "CII", "Ofqual" - body that accredits this source
  accreditationRef String? // "CII/R04/2025" or qualification number

  // Bibliographic metadata
  authors         String[]
  isbn            String?
  doi             String?
  edition         String?  // "37th Edition"
  publicationYear Int?

  // Validity window (critical for regulated content)
  validFrom   DateTime?
  validUntil  DateTime?

  // Qualification coverage
  qualificationRef String?  // "CII R04", "Highfield L2 Food Safety"
  moduleCoverage   String[] // ["R04-LO1", "R04-LO2"] or ["all"]

  // Verification
  verifiedBy        String?   // User ID who verified trust level
  verifiedAt        DateTime?
  verificationNotes String? @db.Text

  // Lifecycle
  isActive       Boolean @default(true)
  supersededById String? @unique // If a newer edition replaces this
  supersededBy   ContentSource? @relation("SourceSupersession", fields: [supersededById], references: [id], onDelete: SetNull)
  supersedes     ContentSource? @relation("SourceSupersession")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  assertions ContentAssertion[]
  curricula  Curriculum[] @relation("CurriculumPrimarySource")
  subjects   SubjectSource[] // Subjects this source belongs to
  mediaAssets MediaAsset[]   // Media files from this content source

  @@index([trustLevel])
  @@index([documentType])
  @@index([qualificationRef])
  @@index([validUntil])
  @@index([isActive])
  @@index([classificationCorrected])
}

// An atomic trusted teaching point with full provenance
model ContentAssertion {
  id String @id @default(uuid())

  // The actual content assertion
  assertion String @db.Text // "The annual ISA allowance is £20,000 for 2025/26"

  // Source provenance
  sourceId String
  source   ContentSource @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  // Location within source
  chapter String? // "Chapter 3", "Learning Outcome 2"
  section String? // "§3.2 ISA Allowances", "AC 2.3"
  pageRef String? // "p.47"

  // Trust (null = inherit from source)
  trustLevel ContentTrustLevel?

  // Content classification
  category String   // "fact", "definition", "threshold", "rule", "process", "example"
  tags     String[] // ["tax", "isa", "allowance", "annual_limit"]

  // Validity (overrides source-level validity for time-bound facts)
  validFrom  DateTime?
  validUntil DateTime?
  taxYear    String?   // "2024/25" - for tax-year-specific facts

  // Exam relevance
  examRelevance      Float?  // 0.0-1.0 how likely to appear in exam
  learningOutcomeRef String? // "R04-LO2-AC2.3"

  // Content hash for dedup/change detection
  contentHash String?

  // Pyramid hierarchy (spec-driven depth/breadth)
  depth      Int?     // Pyramid level (meaning defined by CONTENT-EXTRACT spec levels config)
  parentId   String?  // Self-referential FK for tree structure
  parent     ContentAssertion?  @relation("AssertionHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children   ContentAssertion[] @relation("AssertionHierarchy")
  orderIndex Int      @default(0) // Sort order among siblings
  topicSlug  String?  // Stable topic identifier (e.g., "temperature-control")

  // Vector embedding for semantic search (pgvector)
  embedding Unsupported("vector(1536)")?

  // Review chain
  createdBy  String? // User ID or "system:import"
  reviewedBy String? // User who reviewed
  reviewedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sourceId])
  @@index([trustLevel])
  @@index([category])
  @@index([validUntil])
  @@index([learningOutcomeRef])
  @@index([parentId])
  @@index([depth])
  @@index([topicSlug])
}

// =========================
// SUBJECTS (Content Grouping)
// =========================

// A Subject groups content sources under a teaching topic (e.g., "Food Safety Level 2")
model Subject {
  id          String  @id @default(uuid())
  slug        String  @unique // "food-safety-l2"
  name        String          // "Food Safety Level 2"
  description String? @db.Text

  // Default trust level for documents uploaded to this subject
  defaultTrustLevel ContentTrustLevel @default(UNVERIFIED)

  // Optional qualification metadata
  qualificationBody  String?  // "Highfield", "CII"
  qualificationRef   String?  // "Highfield L2 Food Safety"
  qualificationLevel String?  // "Level 2"

  // Teaching point pyramid depth override (null = use CONTENT-EXTRACT spec default)
  teachingDepth Int?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sources   SubjectSource[]
  domains   SubjectDomain[]
  curricula Curriculum[]
  media     SubjectMedia[]

  @@index([slug])
  @@index([isActive])
}

// Many-to-many: which content sources belong to a subject
model SubjectSource {
  id        String @id @default(uuid())
  subjectId String
  sourceId  String
  subject   Subject       @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  source    ContentSource @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  // Override trust level for this source within this subject (null = inherit subject default)
  trustLevelOverride ContentTrustLevel?

  // Tags: what this document is used for (can be both)
  tags      String[] @default(["content"]) // "syllabus", "content"

  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  @@unique([subjectId, sourceId])
  @@index([subjectId])
  @@index([sourceId])
}

// Many-to-many: which domains teach which subjects
model SubjectDomain {
  id        String @id @default(uuid())
  subjectId String
  domainId  String
  subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  domain    Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([subjectId, domainId])
  @@index([subjectId])
  @@index([domainId])
}

// =============================================================================
// Conversation Artifacts — content shared after calls
// =============================================================================

// ConversationArtifact - Content extracted from calls worth sharing with the caller
// Channel-agnostic: works in Sim (Phase 1) and WhatsApp (Phase 2)
model ConversationArtifact {
  id String @id @default(uuid())

  // Source — callId is null for educator-created artifacts
  callId   String?
  call     Call?   @relation(fields: [callId], references: [id], onDelete: Cascade)
  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  // Provenance — userId of creator (educator, operator); null for AI-extracted
  createdBy String?

  // Content
  type      ConversationArtifactType // SUMMARY, KEY_FACT, FORMULA, EXERCISE, etc.
  title     String // Short descriptive title
  content   String @db.Text // Markdown text body
  mediaUrl  String? // For images/PDFs — URL to stored media (legacy, use mediaId)
  mediaType String? // MIME type: image/png, application/pdf, audio/mpeg

  // Structured media reference (preferred over mediaUrl)
  mediaId String?
  media   MediaAsset? @relation(fields: [mediaId], references: [id], onDelete: SetNull)

  // Trust chain — links to ContentAssertion IDs for provenance
  contentAssertionIds String[] // Array of ContentAssertion IDs
  trustLevel          ArtifactTrustLevel @default(INFERRED)

  // Extraction metadata
  confidence Float @default(0.8) // 0-1: extraction confidence
  evidence   String? @db.Text // Transcript excerpt that triggered extraction

  // Delivery
  status             ArtifactStatus @default(PENDING)
  channel            String         @default("sim") // "sim" | "whatsapp"
  externalMessageId  String? // WhatsApp message ID (Phase 2)
  deliveredAt        DateTime?
  readAt             DateTime?

  // Actions that reference this artifact
  actions CallAction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([callId])
  @@index([callerId])
  @@index([callerId, status])
  @@index([status])
  @@index([mediaId])
}

// CallAction - Actionable items that emerge from calls (homework, follow-ups, media to send)
// Different lifecycle from Artifacts: PENDING → IN_PROGRESS → COMPLETED (completion, not delivery)
model CallAction {
  id String @id @default(uuid())

  // Source
  callId   String?
  call     Call?   @relation(fields: [callId], references: [id], onDelete: SetNull)
  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  // Action content
  type        CallActionType
  title       String
  description String? @db.Text

  // Optional media attachment
  mediaUrl  String?
  mediaType String? // MIME type

  // Optional artifact link (action can reference an artifact)
  artifactId String?
  artifact   ConversationArtifact? @relation(fields: [artifactId], references: [id], onDelete: SetNull)

  // Assignment & tracking
  assignee    CallActionAssignee
  status      CallActionStatus   @default(PENDING)
  priority    CallActionPriority @default(MEDIUM)
  dueAt       DateTime?
  completedAt DateTime?
  completedBy String? // User ID, "system", or "agent"

  // Extraction metadata
  source     CallActionSource @default(MANUAL)
  confidence Float            @default(1.0) // 1.0 for manual, 0-1 for extracted
  evidence   String?          @db.Text      // Transcript excerpt

  // Notes
  notes String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID if manual

  @@index([callerId])
  @@index([callId])
  @@index([callerId, status])
  @@index([assignee])
  @@index([status])
}

// InboundMessage - Content sent by callers (sim text input or future WhatsApp messages)
// Processed into CallerMemory for inclusion in next call's prompt
model InboundMessage {
  id String @id @default(uuid())

  callerId String
  caller   Caller @relation(fields: [callerId], references: [id], onDelete: Cascade)

  // Channel
  channel           String  @default("sim") // "sim" | "whatsapp"
  externalMessageId String? // WhatsApp message ID (Phase 2)

  // Content
  type      InboundMessageType @default(TEXT)
  content   String?            @db.Text // Text body or transcription
  mediaUrl  String? // Downloaded + stored media URL
  mediaType String? // MIME type

  // Processing state
  processed   Boolean @default(false)
  processedAs String? // "CALLER_MEMORY", "GOAL_UPDATE", etc.

  createdAt DateTime @default(now())

  @@index([callerId])
  @@index([processed])
}

// =============================================================================
// Media Assets — uploaded files (images, PDFs, audio) for content delivery
// =============================================================================

model MediaAsset {
  id          String @id @default(uuid())
  fileName    String
  fileSize    Int
  mimeType    String // image/png, application/pdf, audio/mpeg
  contentHash String @unique // SHA-256 for deduplication
  storageKey  String // Object key in storage backend
  storageType String @default("gcs") // "gcs" | "local"

  title       String?
  description String?  @db.Text
  tags        String[]

  uploadedBy String
  uploader   User   @relation(fields: [uploadedBy], references: [id])
  sourceId   String?
  source     ContentSource? @relation(fields: [sourceId], references: [id], onDelete: SetNull)
  trustLevel ContentTrustLevel @default(UNVERIFIED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  subjects  SubjectMedia[]
  messages  CallMessage[]
  artifacts ConversationArtifact[]

  @@index([uploadedBy])
  @@index([sourceId])
  @@index([mimeType])
}

// Many-to-many: which media assets belong to a subject's content library
model SubjectMedia {
  id        String     @id @default(uuid())
  subjectId String
  mediaId   String
  subject   Subject    @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  media     MediaAsset @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  sortOrder Int        @default(0)
  createdAt DateTime   @default(now())

  @@unique([subjectId, mediaId])
  @@index([subjectId])
  @@index([mediaId])
}

// Channel configuration — per-domain delivery channel settings
model ChannelConfig {
  id          String   @id @default(uuid())
  channelType String // "sim" | "whatsapp" | "sms"
  domainId    String?
  domain      Domain?  @relation(fields: [domainId], references: [id], onDelete: Cascade)
  isEnabled   Boolean  @default(true)
  config      Json     @default("{}") // Provider-specific: API keys, endpoints, phone numbers
  priority    Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([domainId, channelType])
  @@index([channelType])
}
