import fs from "fs";
import path from "path";
import csv from "csv-parser";
import { PrismaClient } from "@prisma/client";

/**
 * HF Parameter Registry Import
 *
 * Reads the Notion-exported CSV and upserts rows into the `Parameter` table.
 *
 * Usage:
 *   npx ts-node scripts/import-parameters.ts
 * Options:
 *   --file <path>     Override CSV path
 *   --dry-run         Parse and print a summary without writing to DB
 *   --limit <n>       Only process first N rows (for testing)
 */

const prisma = new PrismaClient();

type AnyRow = Record<string, string | undefined>;

function argValue(flag: string): string | undefined {
  const idx = process.argv.indexOf(flag);
  if (idx === -1) return undefined;
  return process.argv[idx + 1];
}

function hasFlag(flag: string): boolean {
  return process.argv.includes(flag);
}

function parseIntSafe(v: string | undefined): number | undefined {
  if (!v) return undefined;
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : undefined;
}

function firstNonEmpty(row: AnyRow, keys: string[]): string | undefined {
  for (const k of keys) {
    const v = row[k];
    if (typeof v === "string" && v.trim().length > 0) return v.trim();
  }
  return undefined;
}

function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/['â€™]/g, "")
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function sectionToDomainGroup(sectionId: string): string {
  const s = sectionId.trim().toUpperCase();
  switch (s) {
    case "A":
      return "Engagement & Purpose";
    case "B":
      return "Roles & Turn-taking";
    case "C":
      return "Social/Cultural";
    case "D":
      return "Grounding & Cognition";
    case "E":
      return "Relationship & Accommodation";
    case "F":
      return "Voice/Prosody";
    case "G":
      return "Emotion & Affect";
    case "H":
      return "Trust & Rapport";
    case "I":
      return "Topic Continuity";
    case "J":
      return "Repair & Error Handling";
    default:
      return "Unclassified";
  }
}

function inferMeasurementMode(sectionId: string, measurementText?: string): "transcript_mvp" | "voice_required" | "hybrid_future" {
  const s = sectionId.trim().toUpperCase();
  if (s === "F") return "voice_required";
  // If measurement explicitly references acoustic/prosody, mark as hybrid_future
  const t = (measurementText || "").toLowerCase();
  if (/(prosod|acoustic|pitch|intonation|energy|loudness|diarization|overlap|speech rate|tempo)/.test(t)) {
    return "hybrid_future";
  }
  return "transcript_mvp";
}

async function main() {
  const dryRun = hasFlag("--dry-run");
  const limit = parseIntSafe(argValue("--limit"));

  const defaultCsvPath = path.resolve(process.cwd(), "backlog/notion-exports/parameters.csv");
  const csvPath = path.resolve(process.cwd(), argValue("--file") || defaultCsvPath);

  if (!fs.existsSync(csvPath)) {
    console.error(`CSV not found at: ${csvPath}`);
    process.exit(1);
  }

  const rows: AnyRow[] = [];
  const headersSeen = new Set<string>();

  await new Promise<void>((resolve, reject) => {
    fs.createReadStream(csvPath)
      .pipe(csv())
      .on("headers", (headers: string[]) => {
        headers.forEach((h) => headersSeen.add(h));
      })
      .on("data", (row: AnyRow) => {
        if (typeof limit === "number" && rows.length >= limit) return;
        rows.push(row);
      })
      .on("error", reject)
      .on("end", () => resolve());
  });

  console.log("\nHF Import: detected CSV headers:");
  console.log(Array.from(headersSeen).sort().map((h) => `- ${h}`).join("\n") || "(none)");

  if (rows.length === 0) {
    console.log("\nNo rows found in CSV. Nothing to do.");
    return;
  }

  // Common header fallbacks (Notion exports vary)
  const nameKeys = ["Name", "Parameter", "parameter", "Parameter Name", "Metric", "Title"];
  const sectionKeys = ["Section", "section", "Section ID", "Group", "Category", "SectionId"];
  const definitionKeys = ["Definition", "definition", "Description", "What it means", "Meaning"];
  const measurementMvpKeys = ["Measurement (MVP)", "Measurement MVP", "measurement_mvp", "MVP Measurement", "Measurement"];
  const measurementVoiceKeys = ["Measurement (Voice)", "Voice Measurement", "measurement_voice", "Voice Only", "Voice-based"];
  const interpHighKeys = ["Interpretation (High)", "High", "High means", "Interpretation High"];
  const interpLowKeys = ["Interpretation (Low)", "Low", "Low means", "Interpretation Low"];
  const domainKeys = ["Domain", "Domain Group", "DomainGroup", "Group (Domain)", "Domain group"];
  const scaleKeys = ["Scale", "scale_type", "Scale Type", "ScaleType"];
  const directionKeys = ["Direction", "directionality", "Directionality"];
  const computedByKeys = ["Computed By", "computed_by", "ComputedBy", "How computed"];
  const isMvpKeys = ["MVP", "MVP Core", "is_mvp_core", "Core", "Include in MVP"];
  const isActiveKeys = ["Active", "is_active", "Enabled", "Status"];

  const toBool = (v?: string): boolean | undefined => {
    if (!v) return undefined;
    const s = v.trim().toLowerCase();
    if (["true", "yes", "y", "1", "on"].includes(s)) return true;
    if (["false", "no", "n", "0", "off"].includes(s)) return false;
    // Notion sometimes exports status like "Active" / "Inactive"
    if (s === "active") return true;
    if (s === "inactive") return false;
    return undefined;
  };

  let created = 0;
  let updated = 0;
  let skipped = 0;

  console.log(`\nHF Import: processing ${rows.length} rows${dryRun ? " (dry-run)" : ""}...\n`);

  for (const [idx, row] of rows.entries()) {
    const name = firstNonEmpty(row, nameKeys);
    if (!name) {
      skipped++;
      console.warn(`Row ${idx + 1}: missing Name/Parameter; skipping.`);
      continue;
    }

    const sectionRaw = firstNonEmpty(row, sectionKeys) || "UNKNOWN";
    const sectionId = sectionRaw.trim().toUpperCase().slice(0, 1); // A..J or U

    const parameterId = slugify(name);
    if (!parameterId) {
      skipped++;
      console.warn(`Row ${idx + 1}: could not slugify name '${name}'; skipping.`);
      continue;
    }

    const definition = firstNonEmpty(row, definitionKeys) || "";
    const measurementMvp = firstNonEmpty(row, measurementMvpKeys);
    const measurementVoiceOnly = firstNonEmpty(row, measurementVoiceKeys);
    const interpretationHigh = firstNonEmpty(row, interpHighKeys);
    const interpretationLow = firstNonEmpty(row, interpLowKeys);

    const domainGroup =
      firstNonEmpty(row, domainKeys) ||
      sectionToDomainGroup(sectionId);

    const scaleType = firstNonEmpty(row, scaleKeys) || "score_0_100";
    const directionality = firstNonEmpty(row, directionKeys) || "higher_is_better";
    const computedBy = firstNonEmpty(row, computedByKeys) || "eval_agent_rubric";

    const isMvpCore = toBool(firstNonEmpty(row, isMvpKeys));
    const isActive = toBool(firstNonEmpty(row, isActiveKeys));

    // Not stored in DB yet, but useful for later migrations/UI.
    const inferredMode = inferMeasurementMode(sectionId, `${measurementMvp || ""} ${measurementVoiceOnly || ""}`);

    if (dryRun) {
      console.log(
        `DRY Row ${idx + 1}: ${parameterId} | section=${sectionId} | domain='${domainGroup}' | mode=${inferredMode}`
      );
      continue;
    }

    const existing = await prisma.parameter.findUnique({ where: { parameterId } });

    const result = await prisma.parameter.upsert({
      where: { parameterId },
      create: {
        parameterId,
        sectionId,
        domainGroup,
        name,
        definition,
        measurementMvp,
        measurementVoiceOnly,
        interpretationHigh,
        interpretationLow,
        scaleType,
        directionality,
        computedBy,
        ...(typeof isMvpCore === "boolean" ? { isMvpCore } : {}),
        ...(typeof isActive === "boolean" ? { isActive } : {}),
      },
      update: {
        sectionId,
        domainGroup,
        name,
        definition,
        measurementMvp,
        measurementVoiceOnly,
        interpretationHigh,
        interpretationLow,
        scaleType,
        directionality,
        computedBy,
        ...(typeof isMvpCore === "boolean" ? { isMvpCore } : {}),
        ...(typeof isActive === "boolean" ? { isActive } : {}),
      },
      select: { parameterId: true },
    });

    if (existing) updated++;
    else created++;

    if ((idx + 1) % 50 === 0) {
      console.log(`Progress: ${idx + 1}/${rows.length} (created=${created}, updated=${updated}, skipped=${skipped})`);
    }

    // Silence unused var warning without removing helpful inference.
    void result;
  }

  console.log(`\nHF Import complete: created=${created}, updated=${updated}, skipped=${skipped}`);
}

main()
  .catch((e) => {
    console.error("Import failed:", e);
    process.exitCode = 1;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });